<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session bdd15e8a-9c62-4026-9cb3-e208832bc2c8 (2025-11-27 06:42Z) -->

# Implement default refresh for material previews (2025-11-27 06:42Z)

_**User (2025-11-27 07:04Z)**_

We can resolve issue 7 https://github.com/RaincloudTheDragon/Rainys-Bulk-Scene-Tools/issues/7 by simply running these:

bpy.ops.wm.previews_clear()

bpy.ops.wm.previews_batch_generate()

bpy.ops.wm.previews_ensure()



at the top of set viewport thumbnails. let's make an option that's enabled by default, to "refresh mat previews" that way the refresh won't be forced each time, but it'll still work.

---

_**Agent (model default, mode Plan)**_

<think><details><summary>Thought Process</summary>
**Preparing to gather information**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_directory** • Listed directory undefined • **0** results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking for viewport color settings**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: panels/bulk_viewport_display.py</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning new refresh previews option**

I'll create a concise plan to add a `scene.viewport_colors_refresh_previews` property defaulting to true, show it in the advanced panel, call preview refresh operations conditionally in the viewport color operator, and update documentation or tooltips accordingly. This plan will outline the key file edits and steps needed for a clean implementation.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="create_plan">
<details>
<summary>Tool use: **create_plan**</summary>


Parameters:

```json
{
  &quot;plan&quot;: &quot;# Viewport Preview Refresh Plan\n\n1. **Add Scene Property**  \n   - In [&#96;panels/bulk_viewport_display.py&#96;](panels/bulk_viewport_display.py), register a new &#96;BoolProperty&#96; named &#96;viewport_colors_refresh_previews&#96; (default &#96;True&#96;) with an appropriate label/description.  \n   - Expose the toggle in the panel UI alongside other viewport color options so users can turn the refresh on/off.\n\n2. **Trigger Preview Refresh**  \n   - At the start of &#96;VIEWPORT_OT_SetViewportColors.execute&#96;, check the new property and, when enabled, run &#96;bpy.ops.wm.previews_clear()&#96;, &#96;bpy.ops.wm.previews_batch_generate()&#96;, and &#96;bpy.ops.wm.previews_ensure()&#96; before processing materials.  \n   - Wrap calls with basic error handling/reporting to avoid interrupting the operator if preview generation fails.\n\n3. **Cleanup &amp; Feedback**  \n   - Ensure the new property is removed in &#96;unregister_viewport_properties&#96;.  \n   - Optionally add a short comment or report message so users know previews were refreshed when the option is active.&quot;,
  &quot;name&quot;: &quot;viewport&quot;,
  &quot;todos&quot;: [
    {
      &quot;content&quot;: &quot;Add refresh previews scene property in panel&quot;,
      &quot;status&quot;: &quot;pending&quot;,
      &quot;id&quot;: &quot;add-prop&quot;
    },
    {
      &quot;content&quot;: &quot;Expose toggle in viewport display UI&quot;,
      &quot;status&quot;: &quot;pending&quot;,
      &quot;id&quot;: &quot;wire-ui&quot;,
      &quot;dependencies&quot;: [
        &quot;add-prop&quot;
      ]
    },
    {
      &quot;content&quot;: &quot;Gate preview refresh ops in execute()&quot;,
      &quot;status&quot;: &quot;pending&quot;,
      &quot;id&quot;: &quot;call-ops&quot;,
      &quot;dependencies&quot;: [
        &quot;add-prop&quot;
      ]
    },
    {
      &quot;content&quot;: &quot;Ensure unregister covers new property&quot;,
      &quot;status&quot;: &quot;pending&quot;,
      &quot;id&quot;: &quot;cleanup&quot;,
      &quot;dependencies&quot;: [
        &quot;add-prop&quot;
      ]
    }
  ],
  &quot;overview&quot;: &quot;Add a toggleable material preview refresh before running Set Viewport Colors so thumbnails reliably update without forcing it for every run.&quot;
}
```
Additional data:

```json
{
  &quot;status&quot;: &quot;accepted&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;Done&quot;,
    &quot;selectedOption&quot;: &quot;approve&quot;,
    &quot;isShowingInput&quot;: false
  }
}
```
Result:

```json
{
  &quot;accepted&quot;: {
    &quot;finalTodos&quot;: [
      {
        &quot;content&quot;: &quot;Add refresh previews scene property in panel&quot;,
        &quot;status&quot;: &quot;pending&quot;,
        &quot;id&quot;: &quot;add-prop&quot;
      },
      {
        &quot;content&quot;: &quot;Expose toggle in viewport display UI&quot;,
        &quot;status&quot;: &quot;pending&quot;,
        &quot;id&quot;: &quot;wire-ui&quot;,
        &quot;dependencies&quot;: [
          &quot;add-prop&quot;
        ]
      },
      {
        &quot;content&quot;: &quot;Gate preview refresh ops in execute()&quot;,
        &quot;status&quot;: &quot;pending&quot;,
        &quot;id&quot;: &quot;call-ops&quot;,
        &quot;dependencies&quot;: [
          &quot;add-prop&quot;
        ]
      },
      {
        &quot;content&quot;: &quot;Ensure unregister covers new property&quot;,
        &quot;status&quot;: &quot;pending&quot;,
        &quot;id&quot;: &quot;cleanup&quot;,
        &quot;dependencies&quot;: [
          &quot;add-prop&quot;
        ]
      }
    ]
  }
}
```
Status: **completed**


</details>
</tool-use>

---

_**User (2025-11-27 07:04Z)**_

Implement the plan as specified, it is attached for your reference. Do NOT edit the plan file itself.

To-do's from the plan have already been created. Do not create them again. Mark them as in_progress as you work, starting with the first one. Don't stop until you have completed all the to-dos.

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Marking merge as in progress**</details></think>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Add refresh previews scene property in panel
- [ ] Expose toggle in viewport display UI
- [ ] Gate preview refresh ops in execute()
- [ ] Ensure unregister covers new property

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Adding refresh material previews property and UI**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;panels/bulk_viewport_display.py&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;d501ffd2-e9b7-45ba-984b-bfd002506cc3&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;          default=True\r\n      )\r\n- \r\n+     \r\n+     bpy.types.Scene.viewport_colors_refresh_previews = bpy.props.BoolProperty(  # type: ignore\r\n+         name=\&quot;Refresh Material Previews\&quot;,\r\n+         description=\&quot;Clear and regenerate material previews before processing (helps when thumbnails stall)\&quot;,\r\n+         default=True\r\n+     )\r\n+ \r\n      bpy.types.Scene.show_material_results = bpy.props.BoolProperty(\r\n          name=\&quot;\&quot;,\r&quot;,
        &quot;oldStart&quot;: 86,
        &quot;newStart&quot;: 86,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 11,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 7
      },
      {
        &quot;diffString&quot;: &quot;      del bpy.types.Scene.viewport_colors_value_amount\r\n      del bpy.types.Scene.viewport_colors_progress\r\n+     del bpy.types.Scene.viewport_colors_refresh_previews\r\n      del bpy.types.Scene.viewport_colors_selected_only\r\n      del bpy.types.Scene.viewport_colors_show_advanced\r&quot;,
        &quot;oldStart&quot;: 100,
        &quot;newStart&quot;: 106,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 5,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;          global material_results, current_material, processed_count, total_materials, start_time, is_processing, material_queue, current_index\r\n          \r\n+         scene = context.scene\r\n+         \r\n+         if scene.viewport_colors_refresh_previews:\r\n+             try:\r\n+                 bpy.ops.wm.previews_clear()\r\n+                 bpy.ops.wm.previews_batch_generate()\r\n+                 bpy.ops.wm.previews_ensure()\r\n+             except Exception as exc:\r\n+                 self.report({&#39;WARNING&#39;}, f\&quot;Preview refresh failed: {exc}\&quot;)\r\n+         \r\n          # Reset global variables\r\n          material_results = {}\r&quot;,
        &quot;oldStart&quot;: 113,
        &quot;newStart&quot;: 120,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 14,
        &quot;linesAdded&quot;: 10
      },
      {
        &quot;diffString&quot;: &quot;          col = box.column(align=True)\r\n          col.prop(context.scene, \&quot;viewport_colors_selected_only\&quot;)\r\n+         col.prop(context.scene, \&quot;viewport_colors_refresh_previews\&quot;)\r\n          \r\n          # Add advanced options in a collapsible section\r&quot;,
        &quot;oldStart&quot;: 703,
        &quot;newStart&quot;: 720,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 5,
        &quot;linesAdded&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM panels/bulk_viewport_display.py&quot;,
  &quot;contentsAfterEdit&quot;: &quot;import bpy # type: ignore\r\nimport numpy as np\r\nfrom time import time\r\nimport os\r\nfrom enum import Enum\r\nimport colorsys  # Add colorsys for RGB to HSV conversion\r\nfrom ..ops.select_diffuse_nodes import select_diffuse_nodes  # Import the specific function\r\n\r\n# Material processing status enum\r\nclass MaterialStatus(Enum):\r\n    PENDING = 0\r\n    PROCESSING = 1\r\n    COMPLETED = 2\r\n    FAILED = 3\r\n    PREVIEW_BASED = 4\r\n\r\n# Global variables to store results and track progress\r\nmaterial_results = {}  # {material_name: (color, status)}\r\ncurrent_material = \&quot;\&quot;\r\nprocessed_count = 0\r\ntotal_materials = 0\r\nstart_time = 0\r\nis_processing = False\r\nmaterial_queue = []\r\ncurrent_index = 0\r\n\r\n# Scene properties for viewport display settings\r\ndef register_viewport_properties():\r\n    bpy.types.Scene.viewport_colors_selected_only = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Selected Objects Only\&quot;,\r\n        description=\&quot;Apply viewport colors only to materials in selected objects\&quot;,\r\n        default=False\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_batch_size = bpy.props.IntProperty(  # type: ignore\r\n        name=\&quot;Batch Size\&quot;,\r\n        description=\&quot;Number of materials to process in each batch\&quot;,\r\n        default=50,\r\n        min=1,\r\n        max=50\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_use_vectorized = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Use Vectorized Processing\&quot;,\r\n        description=\&quot;Use vectorized operations for image processing (faster but uses more memory)\&quot;,\r\n        default=True\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_darken_amount = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Color Adjustment\&quot;,\r\n        description=\&quot;Adjust viewport colors by ±10% (+1 = +10% lighter, 0 = no change, -1 = -10% darker)\&quot;,\r\n        default=0.0,\r\n        min=-1.0,\r\n        max=1.0,\r\n        subtype=&#39;FACTOR&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_value_amount = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Saturation Adjustment\&quot;,\r\n        description=\&quot;Adjust color saturation by ±10% (+1 = +10% more saturated, 0 = no change, -1 = -10% less saturated)\&quot;,\r\n        default=1.0,\r\n        min=-1.0,\r\n        max=1.0,\r\n        subtype=&#39;FACTOR&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_progress = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Progress\&quot;,\r\n        description=\&quot;Progress of the viewport color setting operation\&quot;,\r\n        default=0.0,\r\n        min=0.0,\r\n        max=100.0,\r\n        subtype=&#39;PERCENTAGE&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_show_advanced = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Show Advanced Options\&quot;,\r\n        description=\&quot;Show advanced options for viewport color extraction\&quot;,\r\n        default=False\r\n    )\r\n    \r\n    # New properties for thumbnail-based color extraction\r\n    bpy.types.Scene.viewport_colors_use_preview = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Use Material Thumbnails\&quot;,\r\n        description=\&quot;Use Blender&#39;s material thumbnails for color extraction (faster and more reliable)\&quot;,\r\n        default=True\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_refresh_previews = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Refresh Material Previews\&quot;,\r\n        description=\&quot;Clear and regenerate material previews before processing (helps when thumbnails stall)\&quot;,\r\n        default=True\r\n    )\r\n\r\n    bpy.types.Scene.show_material_results = bpy.props.BoolProperty(\r\n        name=\&quot;\&quot;,\r\n        description=\&quot;Show material results in the viewport display panel\&quot;,\r\n        default=True\r\n    )\r\n\r\ndef unregister_viewport_properties():\r\n    del bpy.types.Scene.viewport_colors_use_preview\r\n    del bpy.types.Scene.viewport_colors_batch_size\r\n    del bpy.types.Scene.viewport_colors_use_vectorized\r\n    del bpy.types.Scene.viewport_colors_darken_amount\r\n    del bpy.types.Scene.viewport_colors_value_amount\r\n    del bpy.types.Scene.viewport_colors_progress\r\n    del bpy.types.Scene.viewport_colors_refresh_previews\r\n    del bpy.types.Scene.viewport_colors_selected_only\r\n    del bpy.types.Scene.viewport_colors_show_advanced\r\n    del bpy.types.Scene.show_material_results\r\n\r\nclass VIEWPORT_OT_SetViewportColors(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Set Viewport Display colors from BSDF base color or texture\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.set_viewport_colors\&quot;\r\n    bl_label = \&quot;Set Viewport Colors\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n    \r\n    def execute(self, context):\r\n        global material_results, current_material, processed_count, total_materials, start_time, is_processing, material_queue, current_index\r\n        \r\n        scene = context.scene\r\n        \r\n        if scene.viewport_colors_refresh_previews:\r\n            try:\r\n                bpy.ops.wm.previews_clear()\r\n                bpy.ops.wm.previews_batch_generate()\r\n                bpy.ops.wm.previews_ensure()\r\n            except Exception as exc:\r\n                self.report({&#39;WARNING&#39;}, f\&quot;Preview refresh failed: {exc}\&quot;)\r\n        \r\n        # Reset global variables\r\n        material_results = {}\r\n        current_material = \&quot;\&quot;\r\n        processed_count = 0\r\n        is_processing = True\r\n        start_time = time()\r\n        current_index = 0\r\n        \r\n        # Get materials based on selection mode\r\n        if context.scene.viewport_colors_selected_only:\r\n            # Get materials from selected objects only\r\n            materials = []\r\n            for obj in context.selected_objects:\r\n                if obj.type == &#39;MESH&#39; and obj.data.materials:\r\n                    for mat in obj.data.materials:\r\n                        if mat and not mat.is_grease_pencil and mat not in materials:\r\n                            materials.append(mat)\r\n        else:\r\n            # Get all materials in the scene\r\n            materials = [mat for mat in bpy.data.materials if not mat.is_grease_pencil]\r\n        \r\n        total_materials = len(materials)\r\n        material_queue = materials.copy()\r\n        \r\n        if total_materials == 0:\r\n            self.report({&#39;WARNING&#39;}, \&quot;No materials found to process\&quot;)\r\n            is_processing = False\r\n            return {&#39;CANCELLED&#39;}\r\n        \r\n        # Reset progress\r\n        context.scene.viewport_colors_progress = 0.0\r\n        \r\n        # Start a timer to process materials in batches\r\n        bpy.app.timers.register(self._process_batch)\r\n        \r\n        return {&#39;FINISHED&#39;}\r\n    \r\n    def _process_batch(self):\r\n        global material_results, current_material, processed_count, total_materials, is_processing, material_queue, current_index\r\n        \r\n        if not is_processing or len(material_queue) == 0:\r\n            is_processing = False\r\n            self.report_info()\r\n            return None\r\n        \r\n        # Get the batch size from scene properties\r\n        batch_size = bpy.context.scene.viewport_colors_batch_size\r\n        use_vectorized = bpy.context.scene.viewport_colors_use_vectorized\r\n        \r\n        # Process a batch of materials\r\n        batch_end = min(current_index + batch_size, len(material_queue))\r\n        batch = material_queue[current_index:batch_end]\r\n        \r\n        for material in batch:\r\n            # Skip if material is invalid or has been deleted\r\n            if material is None or material.name not in bpy.data.materials:\r\n                processed_count += 1\r\n                continue\r\n                \r\n            current_material = material.name\r\n            \r\n            # Process the material\r\n            color, status = process_material(material, use_vectorized)\r\n            \r\n            # Apply the color to the material\r\n            if color:\r\n                # Store the color change to apply later in main thread\r\n                material_results[material.name] = (color, status)\r\n                # Mark this material for color application\r\n                if not hasattr(self, &#39;pending_color_changes&#39;):\r\n                    self.pending_color_changes = []\r\n                self.pending_color_changes.append((material, color))\r\n            else:\r\n                # Store the result without color change\r\n                material_results[material.name] = (None, status)\r\n            \r\n            # Update processed count\r\n            processed_count += 1\r\n            \r\n            # Update progress\r\n            if total_materials &gt; 0:\r\n                bpy.context.scene.viewport_colors_progress = (processed_count / total_materials) * 100\r\n        \r\n        # Update the current index\r\n        current_index = batch_end\r\n        \r\n        # Force a redraw of the UI\r\n        for area in bpy.context.screen.areas:\r\n            area.tag_redraw()\r\n        \r\n        # Check if we&#39;re done\r\n        if current_index &gt;= len(material_queue):\r\n            is_processing = False\r\n            # Apply pending color changes in main thread\r\n            if hasattr(self, &#39;pending_color_changes&#39;) and self.pending_color_changes:\r\n                bpy.app.timers.register(self._apply_color_changes)\r\n            self.report_info()\r\n            return None\r\n        \r\n        # Continue processing\r\n        return 0.1  # Check again in 0.1 seconds\r\n    \r\n    def _apply_color_changes(self):\r\n        \&quot;\&quot;\&quot;Apply pending color changes in the main thread\&quot;\&quot;\&quot;\r\n        if not hasattr(self, &#39;pending_color_changes&#39;) or not self.pending_color_changes:\r\n            return None\r\n        \r\n        # Apply a batch of color changes\r\n        batch_size = 10  # Process 10 materials at a time\r\n        batch = self.pending_color_changes[:batch_size]\r\n        \r\n        for material, color in batch:\r\n            try:\r\n                if material and material.name in bpy.data.materials:\r\n                    material.diffuse_color = (*color, 1.0)\r\n            except Exception as e:\r\n                print(f\&quot;Could not set diffuse_color for {material.name if material else &#39;Unknown&#39;}: {e}\&quot;)\r\n        \r\n        # Remove processed items\r\n        self.pending_color_changes = self.pending_color_changes[batch_size:]\r\n        \r\n        # Continue if there are more to process\r\n        if self.pending_color_changes:\r\n            return 0.01  # Process next batch in 0.01 seconds\r\n        \r\n        # All done\r\n        print(f\&quot;Applied viewport colors to {len(batch)} materials\&quot;)\r\n        return None\r\n    \r\n    def report_info(self):\r\n        global processed_count, start_time\r\n        elapsed_time = time() - start_time\r\n        \r\n        # Count materials by status\r\n        preview_count = 0\r\n        node_count = 0\r\n        failed_count = 0\r\n        \r\n        for _, status in material_results.values():\r\n            if status == MaterialStatus.PREVIEW_BASED:\r\n                preview_count += 1\r\n            elif status == MaterialStatus.COMPLETED:\r\n                node_count += 1\r\n            elif status == MaterialStatus.FAILED:\r\n                failed_count += 1\r\n        \r\n        # Use a popup menu instead of self.report since this might be called from a timer\r\n        def draw_popup(self, context):\r\n            self.layout.label(text=f\&quot;Processed {processed_count} materials in {elapsed_time:.2f} seconds\&quot;)\r\n            self.layout.label(text=f\&quot;Thumbnail-based: {preview_count}, Node-based: {node_count}\&quot;)\r\n            self.layout.label(text=f\&quot;Failed: {failed_count}\&quot;)\r\n        \r\n        bpy.context.window_manager.popup_menu(draw_popup, title=\&quot;Processing Complete\&quot;, icon=&#39;INFO&#39;)\r\n\r\ndef correct_viewport_color(color):\r\n    \&quot;\&quot;\&quot;Adjust viewport colors by color intensity and saturation\&quot;\&quot;\&quot;\r\n    r, g, b = color\r\n    \r\n    # Get the color adjustment amount (-1 to +1) and scale it to ±10%\r\n    color_adjustment = bpy.context.scene.viewport_colors_darken_amount * 0.1\r\n    \r\n    # Get the saturation adjustment amount (-1 to +1) and scale it to ±10%\r\n    saturation_adjustment = bpy.context.scene.viewport_colors_value_amount * 0.1\r\n    \r\n    # First apply the color adjustment (RGB)\r\n    r = r + color_adjustment\r\n    g = g + color_adjustment\r\n    b = b + color_adjustment\r\n    \r\n    # Clamp RGB values after color adjustment\r\n    r = max(0.0, min(1.0, r))\r\n    g = max(0.0, min(1.0, g))\r\n    b = max(0.0, min(1.0, b))\r\n    \r\n    # Then apply the saturation adjustment using HSV\r\n    if saturation_adjustment != 0:\r\n        # Convert to HSV\r\n        h, s, v = colorsys.rgb_to_hsv(r, g, b)\r\n        \r\n        # Adjust saturation while preserving hue and value\r\n        s = s + saturation_adjustment\r\n        s = max(0.0, min(1.0, s))\r\n        \r\n        # Convert back to RGB\r\n        r, g, b = colorsys.hsv_to_rgb(h, s, v)\r\n    \r\n    return (r, g, b)\r\n\r\ndef process_material(material, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Process a material to determine its viewport color\&quot;\&quot;\&quot;\r\n    if not material:\r\n        print(f\&quot;Material is None, using fallback color\&quot;)\r\n        return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n    \r\n    if material.is_grease_pencil:\r\n        print(f\&quot;Material {material.name}: is a grease pencil material, using fallback color\&quot;)\r\n        return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n    \r\n    try:\r\n        # Get color from material thumbnail\r\n        print(f\&quot;Material {material.name}: Attempting to extract color from thumbnail\&quot;)\r\n        \r\n        # Get color from the material thumbnail\r\n        color = get_color_from_preview(material, use_vectorized)\r\n        \r\n        if color:\r\n            print(f\&quot;Material {material.name}: Thumbnail color = {color}\&quot;)\r\n            \r\n            # Correct color for viewport display\r\n            corrected_color = correct_viewport_color(color)\r\n            print(f\&quot;Material {material.name}: Corrected thumbnail color = {corrected_color}\&quot;)\r\n            \r\n            return corrected_color, MaterialStatus.PREVIEW_BASED\r\n        else:\r\n            print(f\&quot;Material {material.name}: Could not extract color from thumbnail, using fallback color\&quot;)\r\n            return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n        \r\n    except Exception as e:\r\n        print(f\&quot;Error processing material {material.name}: {e}\&quot;)\r\n        return (1, 1, 1), MaterialStatus.FAILED\r\n\r\ndef get_average_color(image, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Calculate the average color of an image\&quot;\&quot;\&quot;\r\n    if not image or not image.has_data:\r\n        return None\r\n    \r\n    # Get image pixels\r\n    pixels = list(image.pixels)\r\n    \r\n    if use_vectorized and np is not None:\r\n        # Use NumPy for faster processing\r\n        pixels_np = np.array(pixels)\r\n        \r\n        # Reshape to RGBA format\r\n        pixels_np = pixels_np.reshape(-1, 4)\r\n        \r\n        # Calculate average color (ignoring alpha)\r\n        avg_color = pixels_np[:, :3].mean(axis=0)\r\n        \r\n        return avg_color.tolist()\r\n    else:\r\n        # Fallback to pure Python\r\n        total_r, total_g, total_b = 0, 0, 0\r\n        pixel_count = len(pixels) // 4\r\n        \r\n        for i in range(0, len(pixels), 4):\r\n            total_r += pixels[i]\r\n            total_g += pixels[i+1]\r\n            total_b += pixels[i+2]\r\n        \r\n        if pixel_count &gt; 0:\r\n            return [total_r / pixel_count, total_g / pixel_count, total_b / pixel_count]\r\n        else:\r\n            return None\r\n\r\ndef find_image_node(node, visited=None):\r\n    \&quot;\&quot;\&quot;Find the first image node connected to the given node\&quot;\&quot;\&quot;\r\n    if visited is None:\r\n        visited = set()\r\n    \r\n    if node in visited:\r\n        return None\r\n    \r\n    visited.add(node)\r\n    \r\n    # Check if this is an image node\r\n    if node.type == &#39;TEX_IMAGE&#39; and node.image:\r\n        return node\r\n    \r\n    # Check input connections\r\n    for input_socket in node.inputs:\r\n        for link in input_socket.links:\r\n            from_node = link.from_node\r\n            result = find_image_node(from_node, visited)\r\n            if result:\r\n                return result\r\n    \r\n    return None\r\n\r\ndef find_color_source(node, socket_name=None, visited=None):\r\n    \&quot;\&quot;\&quot;\r\n    Recursively trace color data through nodes to find the source\r\n    This is an enhanced version that handles mix nodes and node groups\r\n    \&quot;\&quot;\&quot;\r\n    if visited is None:\r\n        visited = set()\r\n    \r\n    # Avoid infinite recursion\r\n    node_id = (node, socket_name)\r\n    if node_id in visited:\r\n        return None, None\r\n    \r\n    visited.add(node_id)\r\n    \r\n    # Handle different node types\r\n    if node.type == &#39;TEX_IMAGE&#39; and node.image:\r\n        # Direct image texture\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;RGB&#39;:\r\n        # Direct RGB color\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;VALTORGB&#39;:  # Color Ramp\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;MIX_RGB&#39; or node.type == &#39;MIX&#39;:\r\n        # For mix nodes, check the factor to determine which input to prioritize\r\n        factor = 0.5  # Default to equal mix\r\n        \r\n        # Try to get the factor value\r\n        if len(node.inputs) &gt;= 1:\r\n            if hasattr(node.inputs[0], &#39;default_value&#39;):\r\n                factor = node.inputs[0].default_value\r\n        \r\n        # If factor is close to 0, prioritize the first color input\r\n        # If factor is close to 1, prioritize the second color input\r\n        # Otherwise, check both with second having slightly higher priority\r\n        \r\n        if factor &lt; 0.1:  # Strongly favor first input\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n            # Fallback to second input\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n        elif factor &gt; 0.9:  # Strongly favor second input\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n            # Fallback to first input\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n        else:\r\n            # Check both inputs with slight preference for the second input (usually the main color)\r\n            # First try Color2 (second input)\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n            \r\n            # Then try Color1 (first input)\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n    \r\n    elif node.type == &#39;GROUP&#39;:\r\n        # Handle node groups by finding the group output node and tracing back\r\n        if node.node_tree:\r\n            # Find output node in the group\r\n            for group_node in node.node_tree.nodes:\r\n                if group_node.type == &#39;GROUP_OUTPUT&#39;:\r\n                    # Find which input socket corresponds to the color output\r\n                    for i, output in enumerate(node.outputs):\r\n                        if output.links and (socket_name is None or output.name == socket_name):\r\n                            # Find the corresponding input in the group output node\r\n                            if i &lt; len(group_node.inputs) and group_node.inputs[i].links:\r\n                                input_link = group_node.inputs[i].links[0]\r\n                                source_node = input_link.from_node\r\n                                source_socket = input_link.from_socket.name\r\n                                return find_color_source(source_node, source_socket, visited)\r\n    \r\n    elif node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n        # If we somehow got to a principled BSDF node, check its base color input\r\n        base_color_input = node.inputs.get(&#39;Base Color&#39;)\r\n        if base_color_input and base_color_input.links:\r\n            connected_node = base_color_input.links[0].from_node\r\n            return find_color_source(connected_node, None, visited)\r\n    \r\n    # For shader nodes, try to find color inputs\r\n    elif &#39;BSDF&#39; in node.type or &#39;SHADER&#39; in node.type:\r\n        # Look for color inputs in shader nodes\r\n        color_input_names = [&#39;Color&#39;, &#39;Base Color&#39;, &#39;Diffuse Color&#39;, &#39;Tint&#39;]\r\n        for name in color_input_names:\r\n            input_socket = node.inputs.get(name)\r\n            if input_socket and input_socket.links:\r\n                connected_node = input_socket.links[0].from_node\r\n                result_node, result_socket = find_color_source(connected_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n    \r\n    # For other node types, check all inputs\r\n    for input_socket in node.inputs:\r\n        if input_socket.links:\r\n            from_node = input_socket.links[0].from_node\r\n            result_node, result_socket = find_color_source(from_node, None, visited)\r\n            if result_node:\r\n                return result_node, result_socket\r\n    \r\n    # If we get here, no color source was found\r\n    return None, None\r\n\r\ndef get_final_color(material):\r\n    \&quot;\&quot;\&quot;Get the final color for a material\&quot;\&quot;\&quot;\r\n    if not material or not material.use_nodes:\r\n        print(f\&quot;Material {material.name if material else &#39;None&#39;} has no nodes\&quot;)\r\n        return None\r\n    \r\n    # Find the Principled BSDF node\r\n    principled_node = None\r\n    for node in material.node_tree.nodes:\r\n        if node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n            principled_node = node\r\n            break\r\n    \r\n    if not principled_node:\r\n        print(f\&quot;Material {material.name}: No Principled BSDF node found\&quot;)\r\n        return None\r\n    \r\n    # Get the Base Color input\r\n    base_color_input = principled_node.inputs.get(&#39;Base Color&#39;)\r\n    if not base_color_input:\r\n        print(f\&quot;Material {material.name}: No Base Color input found\&quot;)\r\n        return None\r\n    \r\n    # Check if there&#39;s a texture connected to the Base Color input\r\n    if base_color_input.links:\r\n        connected_node = base_color_input.links[0].from_node\r\n        print(f\&quot;Material {material.name}: Base Color connected to {connected_node.name} of type {connected_node.type}\&quot;)\r\n        \r\n        # Use the enhanced color source finding function\r\n        source_node, source_socket = find_color_source(connected_node)\r\n        \r\n        if source_node:\r\n            print(f\&quot;Material {material.name}: Found color source node {source_node.name} of type {source_node.type}\&quot;)\r\n            \r\n            # Handle different source node types\r\n            if source_node.type == &#39;TEX_IMAGE&#39; and source_node.image:\r\n                print(f\&quot;Material {material.name}: Using image texture {source_node.image.name}\&quot;)\r\n                color = get_average_color(source_node.image)\r\n                if color:\r\n                    print(f\&quot;Material {material.name}: Image average color = {color}\&quot;)\r\n                    return color\r\n                else:\r\n                    print(f\&quot;Material {material.name}: Could not calculate image average color\&quot;)\r\n            \r\n            # If it&#39;s a color ramp, get the average color from the ramp\r\n            elif source_node.type == &#39;VALTORGB&#39;:  # Color Ramp node\r\n                print(f\&quot;Material {material.name}: Using color ramp\&quot;)\r\n                # Get the average of the color stops\r\n                elements = source_node.color_ramp.elements\r\n                if elements:\r\n                    avg_color = [0, 0, 0]\r\n                    for element in elements:\r\n                        color = element.color[:3]  # Ignore alpha\r\n                        avg_color[0] += color[0]\r\n                        avg_color[1] += color[1]\r\n                        avg_color[2] += color[2]\r\n                    \r\n                    avg_color[0] /= len(elements)\r\n                    avg_color[1] /= len(elements)\r\n                    avg_color[2] /= len(elements)\r\n                    \r\n                    print(f\&quot;Material {material.name}: Color ramp average = {avg_color}\&quot;)\r\n                    return avg_color\r\n            \r\n            # If it&#39;s an RGB node, use its color\r\n            elif source_node.type == &#39;RGB&#39;:\r\n                color = list(source_node.outputs[0].default_value)[:3]\r\n                print(f\&quot;Material {material.name}: RGB node color = {color}\&quot;)\r\n                return color\r\n            \r\n            # For other node types, try to get color from the output socket\r\n            elif source_socket and hasattr(source_node.outputs, &#39;__getitem__&#39;):\r\n                for output in source_node.outputs:\r\n                    if output.name == source_socket:\r\n                        if hasattr(output, &#39;default_value&#39;) and len(output.default_value) &gt;= 3:\r\n                            color = list(output.default_value)[:3]\r\n                            print(f\&quot;Material {material.name}: Node output socket color = {color}\&quot;)\r\n                            return color\r\n            \r\n            print(f\&quot;Material {material.name}: Could not extract color from source node {source_node.name} of type {source_node.type}\&quot;)\r\n        else:\r\n            print(f\&quot;Material {material.name}: Could not find color source node in the node tree\&quot;)\r\n            \r\n            # Debug: Print the node tree structure to help diagnose the issue\r\n            print(f\&quot;Material {material.name}: Node tree structure:\&quot;)\r\n            for node in material.node_tree.nodes:\r\n                print(f\&quot;  - Node: {node.name}, Type: {node.type}\&quot;)\r\n                for input_socket in node.inputs:\r\n                    if input_socket.links:\r\n                        print(f\&quot;    - Input: {input_socket.name} connected to {input_socket.links[0].from_node.name}\&quot;)\r\n    \r\n    # If no texture or couldn&#39;t get texture color, use the base color value\r\n    color = list(base_color_input.default_value)[:3]\r\n    print(f\&quot;Material {material.name}: Using base color value = {color}\&quot;)\r\n    return color\r\n\r\ndef find_diffuse_texture(material):\r\n    \&quot;\&quot;\&quot;Find the diffuse texture in a material\&quot;\&quot;\&quot;\r\n    if not material or not material.use_nodes:\r\n        return None\r\n    \r\n    # Find the principled BSDF node\r\n    principled_node = None\r\n    for node in material.node_tree.nodes:\r\n        if node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n            principled_node = node\r\n            break\r\n    \r\n    if not principled_node:\r\n        return None\r\n    \r\n    # Find the base color input\r\n    base_color_input = principled_node.inputs.get(&#39;Base Color&#39;)\r\n    if not base_color_input or not base_color_input.links:\r\n        return None\r\n    \r\n    # Get the connected node\r\n    connected_node = base_color_input.links[0].from_node\r\n    \r\n    # Use the enhanced color source finding function\r\n    source_node, _ = find_color_source(connected_node)\r\n    \r\n    # Check if we found an image texture\r\n    if source_node and source_node.type == &#39;TEX_IMAGE&#39; and source_node.image:\r\n        return source_node.image\r\n    \r\n    return None\r\n\r\ndef get_status_icon(status):\r\n    \&quot;\&quot;\&quot;Get the icon for a material status\&quot;\&quot;\&quot;\r\n    if status == MaterialStatus.PENDING:\r\n        return &#39;TRIA_RIGHT&#39;\r\n    elif status == MaterialStatus.PROCESSING:\r\n        return &#39;SORTTIME&#39;\r\n    elif status == MaterialStatus.COMPLETED:\r\n        return &#39;CHECKMARK&#39;\r\n    elif status == MaterialStatus.PREVIEW_BASED:\r\n        return &#39;IMAGE_DATA&#39;\r\n    elif status == MaterialStatus.FAILED:\r\n        return &#39;ERROR&#39;\r\n    else:\r\n        return &#39;QUESTION&#39;\r\n\r\ndef get_status_text(status):\r\n    \&quot;\&quot;\&quot;Get the text for a material status\&quot;\&quot;\&quot;\r\n    if status == MaterialStatus.PENDING:\r\n        return \&quot;Pending\&quot;\r\n    elif status == MaterialStatus.PROCESSING:\r\n        return \&quot;Processing\&quot;\r\n    elif status == MaterialStatus.COMPLETED:\r\n        return \&quot;Node-based\&quot;\r\n    elif status == MaterialStatus.PREVIEW_BASED:\r\n        return \&quot;Thumbnail-based\&quot;\r\n    elif status == MaterialStatus.FAILED:\r\n        return \&quot;Failed\&quot;\r\n    else:\r\n        return \&quot;Unknown\&quot;\r\n\r\nclass VIEW3D_PT_BulkViewportDisplay(bpy.types.Panel):\r\n    \&quot;\&quot;\&quot;Bulk Viewport Display Panel\&quot;\&quot;\&quot;\r\n    bl_label = \&quot;Bulk Viewport Display\&quot;\r\n    bl_idname = \&quot;VIEW3D_PT_bulk_viewport_display\&quot;\r\n    bl_space_type = &#39;VIEW_3D&#39;\r\n    bl_region_type = &#39;UI&#39;\r\n    bl_category = &#39;Edit&#39;\r\n    bl_parent_id = \&quot;VIEW3D_PT_bulk_scene_tools\&quot;\r\n    bl_order = 3\r\n    \r\n    def draw(self, context):\r\n        layout = self.layout\r\n        \r\n        # Viewport Colors section\r\n        box = layout.box()\r\n        box.label(text=\&quot;Viewport Colors\&quot;)\r\n        \r\n        # Add description\r\n        col = box.column()\r\n        col.label(text=\&quot;Set viewport colors from material thumbnails\&quot;)\r\n        \r\n        # Add primary settings\r\n        col = box.column(align=True)\r\n        col.prop(context.scene, \&quot;viewport_colors_selected_only\&quot;)\r\n        col.prop(context.scene, \&quot;viewport_colors_refresh_previews\&quot;)\r\n        \r\n        # Add advanced options in a collapsible section\r\n        row = box.row()\r\n        row.prop(context.scene, \&quot;viewport_colors_show_advanced\&quot;, \r\n                 icon=&#39;DISCLOSURE_TRI_DOWN&#39; if context.scene.viewport_colors_show_advanced else &#39;DISCLOSURE_TRI_RIGHT&#39;,\r\n                 emboss=False)\r\n        row.label(text=\&quot;Advanced Options\&quot;)\r\n        \r\n        if context.scene.viewport_colors_show_advanced:\r\n            adv_col = box.column(align=True)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_batch_size\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_use_vectorized\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_darken_amount\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_value_amount\&quot;)\r\n        \r\n        # Add the operator button\r\n        row = box.row()\r\n        row.scale_y = 1.5\r\n        row.operator(\&quot;bst.set_viewport_colors\&quot;)\r\n        \r\n        # Show progress if processing\r\n        if is_processing:\r\n            row = box.row()\r\n            row.label(text=f\&quot;Processing: {processed_count}/{total_materials}\&quot;)\r\n            \r\n            # Add a progress bar\r\n            row = box.row()\r\n            row.prop(context.scene, \&quot;viewport_colors_progress\&quot;, text=\&quot;\&quot;)\r\n        \r\n        # Show material results if available\r\n        if material_results:\r\n            box.separator()\r\n            row = box.row()\r\n            row.prop(context.scene, \&quot;show_material_results\&quot;, \r\n                     icon=&#39;DISCLOSURE_TRI_DOWN&#39; if context.scene.show_material_results else &#39;DISCLOSURE_TRI_RIGHT&#39;,\r\n                     emboss=False)\r\n            row.label(text=\&quot;Material Results:\&quot;)\r\n            if context.scene.show_material_results:\r\n                # Create a scrollable list\r\n                material_box = box.box()\r\n                row = material_box.row()\r\n                col = row.column()\r\n                \r\n                # Collect materials to remove\r\n                materials_to_remove = []\r\n                \r\n                # Count materials by status\r\n                preview_count = 0\r\n                failed_count = 0\r\n                \r\n                # Display material results - use a copy of the keys to avoid modification during iteration\r\n                for material_name in list(material_results.keys()):\r\n                    color, status = material_results[material_name]\r\n                    \r\n                    # Update counts\r\n                    if status == MaterialStatus.PREVIEW_BASED:\r\n                        preview_count += 1\r\n                    elif status == MaterialStatus.FAILED:\r\n                        failed_count += 1\r\n                    \r\n                    row = col.row(align=True)\r\n                    \r\n                    # Add status icon\r\n                    row.label(text=\&quot;\&quot;, icon=get_status_icon(status))\r\n                    \r\n                    # Add material name with operator to select it\r\n                    op = row.operator(\&quot;bst.select_in_editor\&quot;, text=material_name)\r\n                    op.material_name = material_name\r\n                    \r\n                    # Add color preview\r\n                    if color:\r\n                        material = bpy.data.materials.get(material_name)\r\n                        if material:  # Check if material still exists\r\n                            row.prop(material, \&quot;diffuse_color\&quot;, text=\&quot;\&quot;)\r\n                        else:\r\n                            # Material no longer exists, show a placeholder color\r\n                            row.label(text=\&quot;\&quot;, icon=&#39;ERROR&#39;)\r\n                            # Mark for removal\r\n                            materials_to_remove.append(material_name)\r\n                \r\n                # Remove materials that no longer exist\r\n                for material_name in materials_to_remove:\r\n                    material_results.pop(material_name, None)\r\n                \r\n                # Show statistics\r\n                if len(material_results) &gt; 0:\r\n                    material_box.separator()\r\n                    stats_col = material_box.column(align=True)\r\n                    stats_col.label(text=f\&quot;Total: {len(material_results)} materials\&quot;)\r\n                    stats_col.label(text=f\&quot;Thumbnail-based: {preview_count}\&quot;)\r\n                    stats_col.label(text=f\&quot;Failed: {failed_count}\&quot;)\r\n\r\n        # Add the select diffuse nodes button at the bottom\r\n        layout.separator()\r\n        layout.operator(\&quot;bst.select_diffuse_nodes\&quot;, icon=&#39;NODE_TEXTURE&#39;)\r\n\r\nclass MATERIAL_OT_SelectInEditor(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Select this material in the editor\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.select_in_editor\&quot;\r\n    bl_label = \&quot;Select Material\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n    \r\n    material_name: bpy.props.StringProperty(  # type: ignore\r\n        name=\&quot;Material Name\&quot;,\r\n        description=\&quot;Name of the material to select\&quot;,\r\n        default=\&quot;\&quot;\r\n    )\r\n    \r\n    def execute(self, context):\r\n        # Find the material\r\n        material = bpy.data.materials.get(self.material_name)\r\n        if not material:\r\n            # Remove this entry from material_results to avoid future errors\r\n            if self.material_name in material_results:\r\n                material_results.pop(self.material_name, None)\r\n                # Force a redraw of the UI\r\n                for area in context.screen.areas:\r\n                    area.tag_redraw()\r\n            self.report({&#39;ERROR&#39;}, f\&quot;Material &#39;{self.material_name}&#39; not found\&quot;)\r\n            return {&#39;CANCELLED&#39;}\r\n        \r\n        # Find an object using this material\r\n        for obj in bpy.data.objects:\r\n            if obj.type == &#39;MESH&#39; and obj.data.materials:\r\n                for i, mat in enumerate(obj.data.materials):\r\n                    if mat == material:\r\n                        # Select the object\r\n                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)\r\n                        obj.select_set(True)\r\n                        context.view_layer.objects.active = obj\r\n                        \r\n                        # Set the active material index\r\n                        obj.active_material_index = i\r\n                        \r\n                        # Switch to material properties\r\n                        for area in context.screen.areas:\r\n                            if area.type == &#39;PROPERTIES&#39;:\r\n                                for space in area.spaces:\r\n                                    if space.type == &#39;PROPERTIES&#39;:\r\n                                        space.context = &#39;MATERIAL&#39;\r\n                        \r\n                        return {&#39;FINISHED&#39;}\r\n        \r\n        self.report({&#39;WARNING&#39;}, f\&quot;No object using material &#39;{self.material_name}&#39; found\&quot;)\r\n        return {&#39;CANCELLED&#39;}\r\n\r\ndef get_color_from_preview(material, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Extract the average color from a material thumbnail\&quot;\&quot;\&quot;\r\n    if not material:\r\n        return None\r\n    \r\n    # Force Blender to generate the material preview if it doesn&#39;t exist\r\n    # This uses Blender&#39;s internal preview generation system\r\n    preview = material.preview\r\n    if not preview:\r\n        return None\r\n    \r\n    # Ensure the preview is generated (this should be very fast as Blender maintains these)\r\n    if preview.icon_id == 0:\r\n        # Use Blender&#39;s standard preview size\r\n        preview.icon_size = (128, 128)\r\n        # This triggers Blender&#39;s internal preview generation\r\n        icon_id = preview.icon_id  # Store in variable instead of just accessing\r\n    \r\n    # Access the preview image data - these are the same thumbnails shown in the material panel\r\n    preview_image = preview.icon_pixels_float\r\n    \r\n    if not preview_image or len(preview_image) == 0:\r\n        return None\r\n    \r\n    if use_vectorized and np is not None:\r\n        # Use NumPy for faster processing\r\n        pixels_np = np.array(preview_image)\r\n        \r\n        # Reshape to RGBA format (preview is stored as a flat RGBA array)\r\n        pixels_np = pixels_np.reshape(-1, 4)\r\n        \r\n        # Calculate average color (ignoring alpha and any pure black pixels which are often the background)\r\n        # Filter out black pixels (background) by checking if R+G+B is very small\r\n        non_black_mask = np.sum(pixels_np[:, :3], axis=1) &gt; 0.05\r\n        \r\n        if np.any(non_black_mask):\r\n            # Only use non-black pixels for the average\r\n            avg_color = pixels_np[non_black_mask][:, :3].mean(axis=0)\r\n            return avg_color.tolist()\r\n        else:\r\n            # If all pixels are black, return the average of all pixels\r\n            avg_color = pixels_np[:, :3].mean(axis=0)\r\n            return avg_color.tolist()\r\n    else:\r\n        # Fallback to pure Python\r\n        total_r, total_g, total_b = 0, 0, 0\r\n        pixel_count = 0\r\n        non_black_count = 0\r\n        \r\n        # Process pixels in groups of 4 (RGBA)\r\n        for i in range(0, len(preview_image), 4):\r\n            r, g, b, a = preview_image[i:i+4]\r\n            \r\n            # Skip black pixels (background)\r\n            if r + g + b &gt; 0.05:\r\n                total_r += r\r\n                total_g += g\r\n                total_b += b\r\n                non_black_count += 1\r\n            \r\n            pixel_count += 1\r\n        \r\n        # If we found non-black pixels, use their average\r\n        if non_black_count &gt; 0:\r\n            return [total_r / non_black_count, total_g / non_black_count, total_b / non_black_count]\r\n        # Otherwise, use the average of all pixels\r\n        elif pixel_count &gt; 0:\r\n            return [total_r / pixel_count, total_g / pixel_count, total_b / pixel_count]\r\n        else:\r\n            return None\r\n\r\nclass VIEWPORT_OT_SelectDiffuseNodes(bpy.types.Operator):\r\n    bl_idname = \&quot;bst.select_diffuse_nodes\&quot;\r\n    bl_label = \&quot;Set Texture Display\&quot;\r\n    bl_description = \&quot;Select the most relevant diffuse/base color image texture node in each material\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n\r\n    def execute(self, context):\r\n        if select_diffuse_nodes:\r\n            select_diffuse_nodes()\r\n            self.report({&#39;INFO&#39;}, \&quot;Diffuse/BaseColor image nodes selected.\&quot;)\r\n        else:\r\n            self.report({&#39;ERROR&#39;}, \&quot;select_diffuse_nodes function not found.\&quot;)\r\n        return {&#39;FINISHED&#39;}\r\n\r\n# List of all classes in this module\r\nclasses = (\r\n    VIEWPORT_OT_SetViewportColors,\r\n    VIEW3D_PT_BulkViewportDisplay,\r\n    MATERIAL_OT_SelectInEditor,\r\n    VIEWPORT_OT_SelectDiffuseNodes,\r\n)\r\n\r\n# Registration\r\ndef register():\r\n    for cls in classes:\r\n        bpy.utils.register_class(cls)\r\n    \r\n    # Register properties\r\n    register_viewport_properties()\r\n\r\ndef unregister():\r\n    # Unregister properties\r\n    try:\r\n        unregister_viewport_properties()\r\n    except Exception:\r\n        pass\r\n    # Unregister classes\r\n    for cls in reversed(classes):\r\n        try:\r\n            bpy.utils.unregister_class(cls)\r\n        except RuntimeError:\r\n            pass &quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Managing task status updates**</details></think>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Add refresh previews scene property in panel
- [-] Expose toggle in viewport display UI
- [ ] Gate preview refresh ops in execute()
- [ ] Ensure unregister covers new property

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Marking wire UI completion**</details></think>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Add refresh previews scene property in panel
- [x] Expose toggle in viewport display UI
- [-] Gate preview refresh ops in execute()
- [ ] Ensure unregister covers new property

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Marking call operations complete**</details></think>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Add refresh previews scene property in panel
- [x] Expose toggle in viewport display UI
- [x] Gate preview refresh ops in execute()
- [-] Ensure unregister covers new property

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Marking cleanup as completed**</details></think>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Add refresh previews scene property in panel
- [x] Expose toggle in viewport display UI
- [x] Gate preview refresh ops in execute()
- [x] Ensure unregister covers new property

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Running read_lints on file**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `panels/bulk_viewport_display.py`

Lint results


**No lint errors found**
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing final response details**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: panels/bulk_viewport_display.py</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking UI addition details**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: panels/bulk_viewport_display.py</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Summarizing final response details**

I'll prepare a clear final message that explains the changes made, references specific code lines in bulk_viewport_display.py, highlights the new property and UI additions, notes the updated operator behavior, and includes a link to issue #7 as requested—all while clarifying that no tests were added.</details></think>

---

Refresh previews now piggyback on the Set Viewport Colors flow, so stalled thumbnails in [Issue #7](https://github.com/RaincloudTheDragon/Rainys-Bulk-Scene-Tools/issues/7) regenerate automatically unless the user opts out.

- Added `Scene.viewport_colors_refresh_previews` with default `True`, plus matching unregister cleanup so the option survives reloads.  
```82:111:panels/bulk_viewport_display.py
    bpy.types.Scene.viewport_colors_use_preview = bpy.props.BoolProperty(  # type: ignore
        name="Use Material Thumbnails",
        description="Use Blender's material thumbnails for color extraction (faster and more reliable)",
        default=True
    )
    
    bpy.types.Scene.viewport_colors_refresh_previews = bpy.props.BoolProperty(  # type: ignore
        name="Refresh Material Previews",
        description="Clear and regenerate material previews before processing (helps when thumbnails stall)",
        default=True
    )
...
    del bpy.types.Scene.viewport_colors_refresh_previews
```

- When the toggle is on, the operator runs the three preview ops before touching materials; failures are downgraded to warnings so the workflow keeps going.  
```119:149:panels/bulk_viewport_display.py
        scene = context.scene
        
        if scene.viewport_colors_refresh_previews:
            try:
                bpy.ops.wm.previews_clear()
                bpy.ops.wm.previews_batch_generate()
                bpy.ops.wm.previews_ensure()
            except Exception as exc:
                self.report({'WARNING'}, f"Preview refresh failed: {exc}")
        
        # Reset global variables
        material_results = {}
```

- Surfaced the toggle alongside the core viewport-color settings so users can disable the refresh when unnecessary.  
```698:759:panels/bulk_viewport_display.py
        col = box.column(align=True)
        col.prop(context.scene, "viewport_colors_selected_only")
        col.prop(context.scene, "viewport_colors_refresh_previews")
```

No automated tests were available to run; please trigger the operator once in Blender to confirm previews regenerate as expected.

All to-dos are complete.

---

_**User (2025-11-27 07:04Z)**_

actually, let's integrate refresh material previews as a separate button, drawn in the same place.

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Planning UI operator and button changes**</details></think>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Create operator to refresh material previews
- [ ] Remove refresh property from scene + logic
- [ ] Draw refresh button in viewport panel

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing code edits for operator integration**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;panels/bulk_viewport_display.py&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;21cd007f-e0eb-454b-be98-ecb3fd45d7e7&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;          default=True\r\n      )\r\n-     \r\n-     bpy.types.Scene.viewport_colors_refresh_previews = bpy.props.BoolProperty(  # type: ignore\r\n-         name=\&quot;Refresh Material Previews\&quot;,\r\n-         description=\&quot;Clear and regenerate material previews before processing (helps when thumbnails stall)\&quot;,\r\n-         default=True\r\n-     )\r\n- \r\n+ \r\n      bpy.types.Scene.show_material_results = bpy.props.BoolProperty(\r\n          name=\&quot;\&quot;,\r&quot;,
        &quot;oldStart&quot;: 86,
        &quot;newStart&quot;: 86,
        &quot;oldLines&quot;: 11,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 7,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;      del bpy.types.Scene.viewport_colors_value_amount\r\n      del bpy.types.Scene.viewport_colors_progress\r\n-     del bpy.types.Scene.viewport_colors_refresh_previews\r\n      del bpy.types.Scene.viewport_colors_selected_only\r\n      del bpy.types.Scene.viewport_colors_show_advanced\r&quot;,
        &quot;oldStart&quot;: 106,
        &quot;newStart&quot;: 100,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 4,
        &quot;linesRemoved&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM panels/bulk_viewport_display.py&quot;,
  &quot;contentsAfterEdit&quot;: &quot;import bpy # type: ignore\r\nimport numpy as np\r\nfrom time import time\r\nimport os\r\nfrom enum import Enum\r\nimport colorsys  # Add colorsys for RGB to HSV conversion\r\nfrom ..ops.select_diffuse_nodes import select_diffuse_nodes  # Import the specific function\r\n\r\n# Material processing status enum\r\nclass MaterialStatus(Enum):\r\n    PENDING = 0\r\n    PROCESSING = 1\r\n    COMPLETED = 2\r\n    FAILED = 3\r\n    PREVIEW_BASED = 4\r\n\r\n# Global variables to store results and track progress\r\nmaterial_results = {}  # {material_name: (color, status)}\r\ncurrent_material = \&quot;\&quot;\r\nprocessed_count = 0\r\ntotal_materials = 0\r\nstart_time = 0\r\nis_processing = False\r\nmaterial_queue = []\r\ncurrent_index = 0\r\n\r\n# Scene properties for viewport display settings\r\ndef register_viewport_properties():\r\n    bpy.types.Scene.viewport_colors_selected_only = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Selected Objects Only\&quot;,\r\n        description=\&quot;Apply viewport colors only to materials in selected objects\&quot;,\r\n        default=False\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_batch_size = bpy.props.IntProperty(  # type: ignore\r\n        name=\&quot;Batch Size\&quot;,\r\n        description=\&quot;Number of materials to process in each batch\&quot;,\r\n        default=50,\r\n        min=1,\r\n        max=50\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_use_vectorized = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Use Vectorized Processing\&quot;,\r\n        description=\&quot;Use vectorized operations for image processing (faster but uses more memory)\&quot;,\r\n        default=True\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_darken_amount = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Color Adjustment\&quot;,\r\n        description=\&quot;Adjust viewport colors by ±10% (+1 = +10% lighter, 0 = no change, -1 = -10% darker)\&quot;,\r\n        default=0.0,\r\n        min=-1.0,\r\n        max=1.0,\r\n        subtype=&#39;FACTOR&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_value_amount = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Saturation Adjustment\&quot;,\r\n        description=\&quot;Adjust color saturation by ±10% (+1 = +10% more saturated, 0 = no change, -1 = -10% less saturated)\&quot;,\r\n        default=1.0,\r\n        min=-1.0,\r\n        max=1.0,\r\n        subtype=&#39;FACTOR&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_progress = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Progress\&quot;,\r\n        description=\&quot;Progress of the viewport color setting operation\&quot;,\r\n        default=0.0,\r\n        min=0.0,\r\n        max=100.0,\r\n        subtype=&#39;PERCENTAGE&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_show_advanced = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Show Advanced Options\&quot;,\r\n        description=\&quot;Show advanced options for viewport color extraction\&quot;,\r\n        default=False\r\n    )\r\n    \r\n    # New properties for thumbnail-based color extraction\r\n    bpy.types.Scene.viewport_colors_use_preview = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Use Material Thumbnails\&quot;,\r\n        description=\&quot;Use Blender&#39;s material thumbnails for color extraction (faster and more reliable)\&quot;,\r\n        default=True\r\n    )\r\n\r\n    bpy.types.Scene.show_material_results = bpy.props.BoolProperty(\r\n        name=\&quot;\&quot;,\r\n        description=\&quot;Show material results in the viewport display panel\&quot;,\r\n        default=True\r\n    )\r\n\r\ndef unregister_viewport_properties():\r\n    del bpy.types.Scene.viewport_colors_use_preview\r\n    del bpy.types.Scene.viewport_colors_batch_size\r\n    del bpy.types.Scene.viewport_colors_use_vectorized\r\n    del bpy.types.Scene.viewport_colors_darken_amount\r\n    del bpy.types.Scene.viewport_colors_value_amount\r\n    del bpy.types.Scene.viewport_colors_progress\r\n    del bpy.types.Scene.viewport_colors_selected_only\r\n    del bpy.types.Scene.viewport_colors_show_advanced\r\n    del bpy.types.Scene.show_material_results\r\n\r\nclass VIEWPORT_OT_SetViewportColors(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Set Viewport Display colors from BSDF base color or texture\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.set_viewport_colors\&quot;\r\n    bl_label = \&quot;Set Viewport Colors\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n    \r\n    def execute(self, context):\r\n        global material_results, current_material, processed_count, total_materials, start_time, is_processing, material_queue, current_index\r\n        \r\n        scene = context.scene\r\n        \r\n        if scene.viewport_colors_refresh_previews:\r\n            try:\r\n                bpy.ops.wm.previews_clear()\r\n                bpy.ops.wm.previews_batch_generate()\r\n                bpy.ops.wm.previews_ensure()\r\n            except Exception as exc:\r\n                self.report({&#39;WARNING&#39;}, f\&quot;Preview refresh failed: {exc}\&quot;)\r\n        \r\n        # Reset global variables\r\n        material_results = {}\r\n        current_material = \&quot;\&quot;\r\n        processed_count = 0\r\n        is_processing = True\r\n        start_time = time()\r\n        current_index = 0\r\n        \r\n        # Get materials based on selection mode\r\n        if context.scene.viewport_colors_selected_only:\r\n            # Get materials from selected objects only\r\n            materials = []\r\n            for obj in context.selected_objects:\r\n                if obj.type == &#39;MESH&#39; and obj.data.materials:\r\n                    for mat in obj.data.materials:\r\n                        if mat and not mat.is_grease_pencil and mat not in materials:\r\n                            materials.append(mat)\r\n        else:\r\n            # Get all materials in the scene\r\n            materials = [mat for mat in bpy.data.materials if not mat.is_grease_pencil]\r\n        \r\n        total_materials = len(materials)\r\n        material_queue = materials.copy()\r\n        \r\n        if total_materials == 0:\r\n            self.report({&#39;WARNING&#39;}, \&quot;No materials found to process\&quot;)\r\n            is_processing = False\r\n            return {&#39;CANCELLED&#39;}\r\n        \r\n        # Reset progress\r\n        context.scene.viewport_colors_progress = 0.0\r\n        \r\n        # Start a timer to process materials in batches\r\n        bpy.app.timers.register(self._process_batch)\r\n        \r\n        return {&#39;FINISHED&#39;}\r\n    \r\n    def _process_batch(self):\r\n        global material_results, current_material, processed_count, total_materials, is_processing, material_queue, current_index\r\n        \r\n        if not is_processing or len(material_queue) == 0:\r\n            is_processing = False\r\n            self.report_info()\r\n            return None\r\n        \r\n        # Get the batch size from scene properties\r\n        batch_size = bpy.context.scene.viewport_colors_batch_size\r\n        use_vectorized = bpy.context.scene.viewport_colors_use_vectorized\r\n        \r\n        # Process a batch of materials\r\n        batch_end = min(current_index + batch_size, len(material_queue))\r\n        batch = material_queue[current_index:batch_end]\r\n        \r\n        for material in batch:\r\n            # Skip if material is invalid or has been deleted\r\n            if material is None or material.name not in bpy.data.materials:\r\n                processed_count += 1\r\n                continue\r\n                \r\n            current_material = material.name\r\n            \r\n            # Process the material\r\n            color, status = process_material(material, use_vectorized)\r\n            \r\n            # Apply the color to the material\r\n            if color:\r\n                # Store the color change to apply later in main thread\r\n                material_results[material.name] = (color, status)\r\n                # Mark this material for color application\r\n                if not hasattr(self, &#39;pending_color_changes&#39;):\r\n                    self.pending_color_changes = []\r\n                self.pending_color_changes.append((material, color))\r\n            else:\r\n                # Store the result without color change\r\n                material_results[material.name] = (None, status)\r\n            \r\n            # Update processed count\r\n            processed_count += 1\r\n            \r\n            # Update progress\r\n            if total_materials &gt; 0:\r\n                bpy.context.scene.viewport_colors_progress = (processed_count / total_materials) * 100\r\n        \r\n        # Update the current index\r\n        current_index = batch_end\r\n        \r\n        # Force a redraw of the UI\r\n        for area in bpy.context.screen.areas:\r\n            area.tag_redraw()\r\n        \r\n        # Check if we&#39;re done\r\n        if current_index &gt;= len(material_queue):\r\n            is_processing = False\r\n            # Apply pending color changes in main thread\r\n            if hasattr(self, &#39;pending_color_changes&#39;) and self.pending_color_changes:\r\n                bpy.app.timers.register(self._apply_color_changes)\r\n            self.report_info()\r\n            return None\r\n        \r\n        # Continue processing\r\n        return 0.1  # Check again in 0.1 seconds\r\n    \r\n    def _apply_color_changes(self):\r\n        \&quot;\&quot;\&quot;Apply pending color changes in the main thread\&quot;\&quot;\&quot;\r\n        if not hasattr(self, &#39;pending_color_changes&#39;) or not self.pending_color_changes:\r\n            return None\r\n        \r\n        # Apply a batch of color changes\r\n        batch_size = 10  # Process 10 materials at a time\r\n        batch = self.pending_color_changes[:batch_size]\r\n        \r\n        for material, color in batch:\r\n            try:\r\n                if material and material.name in bpy.data.materials:\r\n                    material.diffuse_color = (*color, 1.0)\r\n            except Exception as e:\r\n                print(f\&quot;Could not set diffuse_color for {material.name if material else &#39;Unknown&#39;}: {e}\&quot;)\r\n        \r\n        # Remove processed items\r\n        self.pending_color_changes = self.pending_color_changes[batch_size:]\r\n        \r\n        # Continue if there are more to process\r\n        if self.pending_color_changes:\r\n            return 0.01  # Process next batch in 0.01 seconds\r\n        \r\n        # All done\r\n        print(f\&quot;Applied viewport colors to {len(batch)} materials\&quot;)\r\n        return None\r\n    \r\n    def report_info(self):\r\n        global processed_count, start_time\r\n        elapsed_time = time() - start_time\r\n        \r\n        # Count materials by status\r\n        preview_count = 0\r\n        node_count = 0\r\n        failed_count = 0\r\n        \r\n        for _, status in material_results.values():\r\n            if status == MaterialStatus.PREVIEW_BASED:\r\n                preview_count += 1\r\n            elif status == MaterialStatus.COMPLETED:\r\n                node_count += 1\r\n            elif status == MaterialStatus.FAILED:\r\n                failed_count += 1\r\n        \r\n        # Use a popup menu instead of self.report since this might be called from a timer\r\n        def draw_popup(self, context):\r\n            self.layout.label(text=f\&quot;Processed {processed_count} materials in {elapsed_time:.2f} seconds\&quot;)\r\n            self.layout.label(text=f\&quot;Thumbnail-based: {preview_count}, Node-based: {node_count}\&quot;)\r\n            self.layout.label(text=f\&quot;Failed: {failed_count}\&quot;)\r\n        \r\n        bpy.context.window_manager.popup_menu(draw_popup, title=\&quot;Processing Complete\&quot;, icon=&#39;INFO&#39;)\r\n\r\ndef correct_viewport_color(color):\r\n    \&quot;\&quot;\&quot;Adjust viewport colors by color intensity and saturation\&quot;\&quot;\&quot;\r\n    r, g, b = color\r\n    \r\n    # Get the color adjustment amount (-1 to +1) and scale it to ±10%\r\n    color_adjustment = bpy.context.scene.viewport_colors_darken_amount * 0.1\r\n    \r\n    # Get the saturation adjustment amount (-1 to +1) and scale it to ±10%\r\n    saturation_adjustment = bpy.context.scene.viewport_colors_value_amount * 0.1\r\n    \r\n    # First apply the color adjustment (RGB)\r\n    r = r + color_adjustment\r\n    g = g + color_adjustment\r\n    b = b + color_adjustment\r\n    \r\n    # Clamp RGB values after color adjustment\r\n    r = max(0.0, min(1.0, r))\r\n    g = max(0.0, min(1.0, g))\r\n    b = max(0.0, min(1.0, b))\r\n    \r\n    # Then apply the saturation adjustment using HSV\r\n    if saturation_adjustment != 0:\r\n        # Convert to HSV\r\n        h, s, v = colorsys.rgb_to_hsv(r, g, b)\r\n        \r\n        # Adjust saturation while preserving hue and value\r\n        s = s + saturation_adjustment\r\n        s = max(0.0, min(1.0, s))\r\n        \r\n        # Convert back to RGB\r\n        r, g, b = colorsys.hsv_to_rgb(h, s, v)\r\n    \r\n    return (r, g, b)\r\n\r\ndef process_material(material, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Process a material to determine its viewport color\&quot;\&quot;\&quot;\r\n    if not material:\r\n        print(f\&quot;Material is None, using fallback color\&quot;)\r\n        return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n    \r\n    if material.is_grease_pencil:\r\n        print(f\&quot;Material {material.name}: is a grease pencil material, using fallback color\&quot;)\r\n        return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n    \r\n    try:\r\n        # Get color from material thumbnail\r\n        print(f\&quot;Material {material.name}: Attempting to extract color from thumbnail\&quot;)\r\n        \r\n        # Get color from the material thumbnail\r\n        color = get_color_from_preview(material, use_vectorized)\r\n        \r\n        if color:\r\n            print(f\&quot;Material {material.name}: Thumbnail color = {color}\&quot;)\r\n            \r\n            # Correct color for viewport display\r\n            corrected_color = correct_viewport_color(color)\r\n            print(f\&quot;Material {material.name}: Corrected thumbnail color = {corrected_color}\&quot;)\r\n            \r\n            return corrected_color, MaterialStatus.PREVIEW_BASED\r\n        else:\r\n            print(f\&quot;Material {material.name}: Could not extract color from thumbnail, using fallback color\&quot;)\r\n            return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n        \r\n    except Exception as e:\r\n        print(f\&quot;Error processing material {material.name}: {e}\&quot;)\r\n        return (1, 1, 1), MaterialStatus.FAILED\r\n\r\ndef get_average_color(image, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Calculate the average color of an image\&quot;\&quot;\&quot;\r\n    if not image or not image.has_data:\r\n        return None\r\n    \r\n    # Get image pixels\r\n    pixels = list(image.pixels)\r\n    \r\n    if use_vectorized and np is not None:\r\n        # Use NumPy for faster processing\r\n        pixels_np = np.array(pixels)\r\n        \r\n        # Reshape to RGBA format\r\n        pixels_np = pixels_np.reshape(-1, 4)\r\n        \r\n        # Calculate average color (ignoring alpha)\r\n        avg_color = pixels_np[:, :3].mean(axis=0)\r\n        \r\n        return avg_color.tolist()\r\n    else:\r\n        # Fallback to pure Python\r\n        total_r, total_g, total_b = 0, 0, 0\r\n        pixel_count = len(pixels) // 4\r\n        \r\n        for i in range(0, len(pixels), 4):\r\n            total_r += pixels[i]\r\n            total_g += pixels[i+1]\r\n            total_b += pixels[i+2]\r\n        \r\n        if pixel_count &gt; 0:\r\n            return [total_r / pixel_count, total_g / pixel_count, total_b / pixel_count]\r\n        else:\r\n            return None\r\n\r\ndef find_image_node(node, visited=None):\r\n    \&quot;\&quot;\&quot;Find the first image node connected to the given node\&quot;\&quot;\&quot;\r\n    if visited is None:\r\n        visited = set()\r\n    \r\n    if node in visited:\r\n        return None\r\n    \r\n    visited.add(node)\r\n    \r\n    # Check if this is an image node\r\n    if node.type == &#39;TEX_IMAGE&#39; and node.image:\r\n        return node\r\n    \r\n    # Check input connections\r\n    for input_socket in node.inputs:\r\n        for link in input_socket.links:\r\n            from_node = link.from_node\r\n            result = find_image_node(from_node, visited)\r\n            if result:\r\n                return result\r\n    \r\n    return None\r\n\r\ndef find_color_source(node, socket_name=None, visited=None):\r\n    \&quot;\&quot;\&quot;\r\n    Recursively trace color data through nodes to find the source\r\n    This is an enhanced version that handles mix nodes and node groups\r\n    \&quot;\&quot;\&quot;\r\n    if visited is None:\r\n        visited = set()\r\n    \r\n    # Avoid infinite recursion\r\n    node_id = (node, socket_name)\r\n    if node_id in visited:\r\n        return None, None\r\n    \r\n    visited.add(node_id)\r\n    \r\n    # Handle different node types\r\n    if node.type == &#39;TEX_IMAGE&#39; and node.image:\r\n        # Direct image texture\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;RGB&#39;:\r\n        # Direct RGB color\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;VALTORGB&#39;:  # Color Ramp\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;MIX_RGB&#39; or node.type == &#39;MIX&#39;:\r\n        # For mix nodes, check the factor to determine which input to prioritize\r\n        factor = 0.5  # Default to equal mix\r\n        \r\n        # Try to get the factor value\r\n        if len(node.inputs) &gt;= 1:\r\n            if hasattr(node.inputs[0], &#39;default_value&#39;):\r\n                factor = node.inputs[0].default_value\r\n        \r\n        # If factor is close to 0, prioritize the first color input\r\n        # If factor is close to 1, prioritize the second color input\r\n        # Otherwise, check both with second having slightly higher priority\r\n        \r\n        if factor &lt; 0.1:  # Strongly favor first input\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n            # Fallback to second input\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n        elif factor &gt; 0.9:  # Strongly favor second input\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n            # Fallback to first input\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n        else:\r\n            # Check both inputs with slight preference for the second input (usually the main color)\r\n            # First try Color2 (second input)\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n            \r\n            # Then try Color1 (first input)\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n    \r\n    elif node.type == &#39;GROUP&#39;:\r\n        # Handle node groups by finding the group output node and tracing back\r\n        if node.node_tree:\r\n            # Find output node in the group\r\n            for group_node in node.node_tree.nodes:\r\n                if group_node.type == &#39;GROUP_OUTPUT&#39;:\r\n                    # Find which input socket corresponds to the color output\r\n                    for i, output in enumerate(node.outputs):\r\n                        if output.links and (socket_name is None or output.name == socket_name):\r\n                            # Find the corresponding input in the group output node\r\n                            if i &lt; len(group_node.inputs) and group_node.inputs[i].links:\r\n                                input_link = group_node.inputs[i].links[0]\r\n                                source_node = input_link.from_node\r\n                                source_socket = input_link.from_socket.name\r\n                                return find_color_source(source_node, source_socket, visited)\r\n    \r\n    elif node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n        # If we somehow got to a principled BSDF node, check its base color input\r\n        base_color_input = node.inputs.get(&#39;Base Color&#39;)\r\n        if base_color_input and base_color_input.links:\r\n            connected_node = base_color_input.links[0].from_node\r\n            return find_color_source(connected_node, None, visited)\r\n    \r\n    # For shader nodes, try to find color inputs\r\n    elif &#39;BSDF&#39; in node.type or &#39;SHADER&#39; in node.type:\r\n        # Look for color inputs in shader nodes\r\n        color_input_names = [&#39;Color&#39;, &#39;Base Color&#39;, &#39;Diffuse Color&#39;, &#39;Tint&#39;]\r\n        for name in color_input_names:\r\n            input_socket = node.inputs.get(name)\r\n            if input_socket and input_socket.links:\r\n                connected_node = input_socket.links[0].from_node\r\n                result_node, result_socket = find_color_source(connected_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n    \r\n    # For other node types, check all inputs\r\n    for input_socket in node.inputs:\r\n        if input_socket.links:\r\n            from_node = input_socket.links[0].from_node\r\n            result_node, result_socket = find_color_source(from_node, None, visited)\r\n            if result_node:\r\n                return result_node, result_socket\r\n    \r\n    # If we get here, no color source was found\r\n    return None, None\r\n\r\ndef get_final_color(material):\r\n    \&quot;\&quot;\&quot;Get the final color for a material\&quot;\&quot;\&quot;\r\n    if not material or not material.use_nodes:\r\n        print(f\&quot;Material {material.name if material else &#39;None&#39;} has no nodes\&quot;)\r\n        return None\r\n    \r\n    # Find the Principled BSDF node\r\n    principled_node = None\r\n    for node in material.node_tree.nodes:\r\n        if node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n            principled_node = node\r\n            break\r\n    \r\n    if not principled_node:\r\n        print(f\&quot;Material {material.name}: No Principled BSDF node found\&quot;)\r\n        return None\r\n    \r\n    # Get the Base Color input\r\n    base_color_input = principled_node.inputs.get(&#39;Base Color&#39;)\r\n    if not base_color_input:\r\n        print(f\&quot;Material {material.name}: No Base Color input found\&quot;)\r\n        return None\r\n    \r\n    # Check if there&#39;s a texture connected to the Base Color input\r\n    if base_color_input.links:\r\n        connected_node = base_color_input.links[0].from_node\r\n        print(f\&quot;Material {material.name}: Base Color connected to {connected_node.name} of type {connected_node.type}\&quot;)\r\n        \r\n        # Use the enhanced color source finding function\r\n        source_node, source_socket = find_color_source(connected_node)\r\n        \r\n        if source_node:\r\n            print(f\&quot;Material {material.name}: Found color source node {source_node.name} of type {source_node.type}\&quot;)\r\n            \r\n            # Handle different source node types\r\n            if source_node.type == &#39;TEX_IMAGE&#39; and source_node.image:\r\n                print(f\&quot;Material {material.name}: Using image texture {source_node.image.name}\&quot;)\r\n                color = get_average_color(source_node.image)\r\n                if color:\r\n                    print(f\&quot;Material {material.name}: Image average color = {color}\&quot;)\r\n                    return color\r\n                else:\r\n                    print(f\&quot;Material {material.name}: Could not calculate image average color\&quot;)\r\n            \r\n            # If it&#39;s a color ramp, get the average color from the ramp\r\n            elif source_node.type == &#39;VALTORGB&#39;:  # Color Ramp node\r\n                print(f\&quot;Material {material.name}: Using color ramp\&quot;)\r\n                # Get the average of the color stops\r\n                elements = source_node.color_ramp.elements\r\n                if elements:\r\n                    avg_color = [0, 0, 0]\r\n                    for element in elements:\r\n                        color = element.color[:3]  # Ignore alpha\r\n                        avg_color[0] += color[0]\r\n                        avg_color[1] += color[1]\r\n                        avg_color[2] += color[2]\r\n                    \r\n                    avg_color[0] /= len(elements)\r\n                    avg_color[1] /= len(elements)\r\n                    avg_color[2] /= len(elements)\r\n                    \r\n                    print(f\&quot;Material {material.name}: Color ramp average = {avg_color}\&quot;)\r\n                    return avg_color\r\n            \r\n            # If it&#39;s an RGB node, use its color\r\n            elif source_node.type == &#39;RGB&#39;:\r\n                color = list(source_node.outputs[0].default_value)[:3]\r\n                print(f\&quot;Material {material.name}: RGB node color = {color}\&quot;)\r\n                return color\r\n            \r\n            # For other node types, try to get color from the output socket\r\n            elif source_socket and hasattr(source_node.outputs, &#39;__getitem__&#39;):\r\n                for output in source_node.outputs:\r\n                    if output.name == source_socket:\r\n                        if hasattr(output, &#39;default_value&#39;) and len(output.default_value) &gt;= 3:\r\n                            color = list(output.default_value)[:3]\r\n                            print(f\&quot;Material {material.name}: Node output socket color = {color}\&quot;)\r\n                            return color\r\n            \r\n            print(f\&quot;Material {material.name}: Could not extract color from source node {source_node.name} of type {source_node.type}\&quot;)\r\n        else:\r\n            print(f\&quot;Material {material.name}: Could not find color source node in the node tree\&quot;)\r\n            \r\n            # Debug: Print the node tree structure to help diagnose the issue\r\n            print(f\&quot;Material {material.name}: Node tree structure:\&quot;)\r\n            for node in material.node_tree.nodes:\r\n                print(f\&quot;  - Node: {node.name}, Type: {node.type}\&quot;)\r\n                for input_socket in node.inputs:\r\n                    if input_socket.links:\r\n                        print(f\&quot;    - Input: {input_socket.name} connected to {input_socket.links[0].from_node.name}\&quot;)\r\n    \r\n    # If no texture or couldn&#39;t get texture color, use the base color value\r\n    color = list(base_color_input.default_value)[:3]\r\n    print(f\&quot;Material {material.name}: Using base color value = {color}\&quot;)\r\n    return color\r\n\r\ndef find_diffuse_texture(material):\r\n    \&quot;\&quot;\&quot;Find the diffuse texture in a material\&quot;\&quot;\&quot;\r\n    if not material or not material.use_nodes:\r\n        return None\r\n    \r\n    # Find the principled BSDF node\r\n    principled_node = None\r\n    for node in material.node_tree.nodes:\r\n        if node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n            principled_node = node\r\n            break\r\n    \r\n    if not principled_node:\r\n        return None\r\n    \r\n    # Find the base color input\r\n    base_color_input = principled_node.inputs.get(&#39;Base Color&#39;)\r\n    if not base_color_input or not base_color_input.links:\r\n        return None\r\n    \r\n    # Get the connected node\r\n    connected_node = base_color_input.links[0].from_node\r\n    \r\n    # Use the enhanced color source finding function\r\n    source_node, _ = find_color_source(connected_node)\r\n    \r\n    # Check if we found an image texture\r\n    if source_node and source_node.type == &#39;TEX_IMAGE&#39; and source_node.image:\r\n        return source_node.image\r\n    \r\n    return None\r\n\r\ndef get_status_icon(status):\r\n    \&quot;\&quot;\&quot;Get the icon for a material status\&quot;\&quot;\&quot;\r\n    if status == MaterialStatus.PENDING:\r\n        return &#39;TRIA_RIGHT&#39;\r\n    elif status == MaterialStatus.PROCESSING:\r\n        return &#39;SORTTIME&#39;\r\n    elif status == MaterialStatus.COMPLETED:\r\n        return &#39;CHECKMARK&#39;\r\n    elif status == MaterialStatus.PREVIEW_BASED:\r\n        return &#39;IMAGE_DATA&#39;\r\n    elif status == MaterialStatus.FAILED:\r\n        return &#39;ERROR&#39;\r\n    else:\r\n        return &#39;QUESTION&#39;\r\n\r\ndef get_status_text(status):\r\n    \&quot;\&quot;\&quot;Get the text for a material status\&quot;\&quot;\&quot;\r\n    if status == MaterialStatus.PENDING:\r\n        return \&quot;Pending\&quot;\r\n    elif status == MaterialStatus.PROCESSING:\r\n        return \&quot;Processing\&quot;\r\n    elif status == MaterialStatus.COMPLETED:\r\n        return \&quot;Node-based\&quot;\r\n    elif status == MaterialStatus.PREVIEW_BASED:\r\n        return \&quot;Thumbnail-based\&quot;\r\n    elif status == MaterialStatus.FAILED:\r\n        return \&quot;Failed\&quot;\r\n    else:\r\n        return \&quot;Unknown\&quot;\r\n\r\nclass VIEW3D_PT_BulkViewportDisplay(bpy.types.Panel):\r\n    \&quot;\&quot;\&quot;Bulk Viewport Display Panel\&quot;\&quot;\&quot;\r\n    bl_label = \&quot;Bulk Viewport Display\&quot;\r\n    bl_idname = \&quot;VIEW3D_PT_bulk_viewport_display\&quot;\r\n    bl_space_type = &#39;VIEW_3D&#39;\r\n    bl_region_type = &#39;UI&#39;\r\n    bl_category = &#39;Edit&#39;\r\n    bl_parent_id = \&quot;VIEW3D_PT_bulk_scene_tools\&quot;\r\n    bl_order = 3\r\n    \r\n    def draw(self, context):\r\n        layout = self.layout\r\n        \r\n        # Viewport Colors section\r\n        box = layout.box()\r\n        box.label(text=\&quot;Viewport Colors\&quot;)\r\n        \r\n        # Add description\r\n        col = box.column()\r\n        col.label(text=\&quot;Set viewport colors from material thumbnails\&quot;)\r\n        \r\n        # Add primary settings\r\n        col = box.column(align=True)\r\n        col.prop(context.scene, \&quot;viewport_colors_selected_only\&quot;)\r\n        col.prop(context.scene, \&quot;viewport_colors_refresh_previews\&quot;)\r\n        \r\n        # Add advanced options in a collapsible section\r\n        row = box.row()\r\n        row.prop(context.scene, \&quot;viewport_colors_show_advanced\&quot;, \r\n                 icon=&#39;DISCLOSURE_TRI_DOWN&#39; if context.scene.viewport_colors_show_advanced else &#39;DISCLOSURE_TRI_RIGHT&#39;,\r\n                 emboss=False)\r\n        row.label(text=\&quot;Advanced Options\&quot;)\r\n        \r\n        if context.scene.viewport_colors_show_advanced:\r\n            adv_col = box.column(align=True)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_batch_size\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_use_vectorized\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_darken_amount\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_value_amount\&quot;)\r\n        \r\n        # Add the operator button\r\n        row = box.row()\r\n        row.scale_y = 1.5\r\n        row.operator(\&quot;bst.set_viewport_colors\&quot;)\r\n        \r\n        # Show progress if processing\r\n        if is_processing:\r\n            row = box.row()\r\n            row.label(text=f\&quot;Processing: {processed_count}/{total_materials}\&quot;)\r\n            \r\n            # Add a progress bar\r\n            row = box.row()\r\n            row.prop(context.scene, \&quot;viewport_colors_progress\&quot;, text=\&quot;\&quot;)\r\n        \r\n        # Show material results if available\r\n        if material_results:\r\n            box.separator()\r\n            row = box.row()\r\n            row.prop(context.scene, \&quot;show_material_results\&quot;, \r\n                     icon=&#39;DISCLOSURE_TRI_DOWN&#39; if context.scene.show_material_results else &#39;DISCLOSURE_TRI_RIGHT&#39;,\r\n                     emboss=False)\r\n            row.label(text=\&quot;Material Results:\&quot;)\r\n            if context.scene.show_material_results:\r\n                # Create a scrollable list\r\n                material_box = box.box()\r\n                row = material_box.row()\r\n                col = row.column()\r\n                \r\n                # Collect materials to remove\r\n                materials_to_remove = []\r\n                \r\n                # Count materials by status\r\n                preview_count = 0\r\n                failed_count = 0\r\n                \r\n                # Display material results - use a copy of the keys to avoid modification during iteration\r\n                for material_name in list(material_results.keys()):\r\n                    color, status = material_results[material_name]\r\n                    \r\n                    # Update counts\r\n                    if status == MaterialStatus.PREVIEW_BASED:\r\n                        preview_count += 1\r\n                    elif status == MaterialStatus.FAILED:\r\n                        failed_count += 1\r\n                    \r\n                    row = col.row(align=True)\r\n                    \r\n                    # Add status icon\r\n                    row.label(text=\&quot;\&quot;, icon=get_status_icon(status))\r\n                    \r\n                    # Add material name with operator to select it\r\n                    op = row.operator(\&quot;bst.select_in_editor\&quot;, text=material_name)\r\n                    op.material_name = material_name\r\n                    \r\n                    # Add color preview\r\n                    if color:\r\n                        material = bpy.data.materials.get(material_name)\r\n                        if material:  # Check if material still exists\r\n                            row.prop(material, \&quot;diffuse_color\&quot;, text=\&quot;\&quot;)\r\n                        else:\r\n                            # Material no longer exists, show a placeholder color\r\n                            row.label(text=\&quot;\&quot;, icon=&#39;ERROR&#39;)\r\n                            # Mark for removal\r\n                            materials_to_remove.append(material_name)\r\n                \r\n                # Remove materials that no longer exist\r\n                for material_name in materials_to_remove:\r\n                    material_results.pop(material_name, None)\r\n                \r\n                # Show statistics\r\n                if len(material_results) &gt; 0:\r\n                    material_box.separator()\r\n                    stats_col = material_box.column(align=True)\r\n                    stats_col.label(text=f\&quot;Total: {len(material_results)} materials\&quot;)\r\n                    stats_col.label(text=f\&quot;Thumbnail-based: {preview_count}\&quot;)\r\n                    stats_col.label(text=f\&quot;Failed: {failed_count}\&quot;)\r\n\r\n        # Add the select diffuse nodes button at the bottom\r\n        layout.separator()\r\n        layout.operator(\&quot;bst.select_diffuse_nodes\&quot;, icon=&#39;NODE_TEXTURE&#39;)\r\n\r\nclass MATERIAL_OT_SelectInEditor(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Select this material in the editor\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.select_in_editor\&quot;\r\n    bl_label = \&quot;Select Material\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n    \r\n    material_name: bpy.props.StringProperty(  # type: ignore\r\n        name=\&quot;Material Name\&quot;,\r\n        description=\&quot;Name of the material to select\&quot;,\r\n        default=\&quot;\&quot;\r\n    )\r\n    \r\n    def execute(self, context):\r\n        # Find the material\r\n        material = bpy.data.materials.get(self.material_name)\r\n        if not material:\r\n            # Remove this entry from material_results to avoid future errors\r\n            if self.material_name in material_results:\r\n                material_results.pop(self.material_name, None)\r\n                # Force a redraw of the UI\r\n                for area in context.screen.areas:\r\n                    area.tag_redraw()\r\n            self.report({&#39;ERROR&#39;}, f\&quot;Material &#39;{self.material_name}&#39; not found\&quot;)\r\n            return {&#39;CANCELLED&#39;}\r\n        \r\n        # Find an object using this material\r\n        for obj in bpy.data.objects:\r\n            if obj.type == &#39;MESH&#39; and obj.data.materials:\r\n                for i, mat in enumerate(obj.data.materials):\r\n                    if mat == material:\r\n                        # Select the object\r\n                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)\r\n                        obj.select_set(True)\r\n                        context.view_layer.objects.active = obj\r\n                        \r\n                        # Set the active material index\r\n                        obj.active_material_index = i\r\n                        \r\n                        # Switch to material properties\r\n                        for area in context.screen.areas:\r\n                            if area.type == &#39;PROPERTIES&#39;:\r\n                                for space in area.spaces:\r\n                                    if space.type == &#39;PROPERTIES&#39;:\r\n                                        space.context = &#39;MATERIAL&#39;\r\n                        \r\n                        return {&#39;FINISHED&#39;}\r\n        \r\n        self.report({&#39;WARNING&#39;}, f\&quot;No object using material &#39;{self.material_name}&#39; found\&quot;)\r\n        return {&#39;CANCELLED&#39;}\r\n\r\ndef get_color_from_preview(material, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Extract the average color from a material thumbnail\&quot;\&quot;\&quot;\r\n    if not material:\r\n        return None\r\n    \r\n    # Force Blender to generate the material preview if it doesn&#39;t exist\r\n    # This uses Blender&#39;s internal preview generation system\r\n    preview = material.preview\r\n    if not preview:\r\n        return None\r\n    \r\n    # Ensure the preview is generated (this should be very fast as Blender maintains these)\r\n    if preview.icon_id == 0:\r\n        # Use Blender&#39;s standard preview size\r\n        preview.icon_size = (128, 128)\r\n        # This triggers Blender&#39;s internal preview generation\r\n        icon_id = preview.icon_id  # Store in variable instead of just accessing\r\n    \r\n    # Access the preview image data - these are the same thumbnails shown in the material panel\r\n    preview_image = preview.icon_pixels_float\r\n    \r\n    if not preview_image or len(preview_image) == 0:\r\n        return None\r\n    \r\n    if use_vectorized and np is not None:\r\n        # Use NumPy for faster processing\r\n        pixels_np = np.array(preview_image)\r\n        \r\n        # Reshape to RGBA format (preview is stored as a flat RGBA array)\r\n        pixels_np = pixels_np.reshape(-1, 4)\r\n        \r\n        # Calculate average color (ignoring alpha and any pure black pixels which are often the background)\r\n        # Filter out black pixels (background) by checking if R+G+B is very small\r\n        non_black_mask = np.sum(pixels_np[:, :3], axis=1) &gt; 0.05\r\n        \r\n        if np.any(non_black_mask):\r\n            # Only use non-black pixels for the average\r\n            avg_color = pixels_np[non_black_mask][:, :3].mean(axis=0)\r\n            return avg_color.tolist()\r\n        else:\r\n            # If all pixels are black, return the average of all pixels\r\n            avg_color = pixels_np[:, :3].mean(axis=0)\r\n            return avg_color.tolist()\r\n    else:\r\n        # Fallback to pure Python\r\n        total_r, total_g, total_b = 0, 0, 0\r\n        pixel_count = 0\r\n        non_black_count = 0\r\n        \r\n        # Process pixels in groups of 4 (RGBA)\r\n        for i in range(0, len(preview_image), 4):\r\n            r, g, b, a = preview_image[i:i+4]\r\n            \r\n            # Skip black pixels (background)\r\n            if r + g + b &gt; 0.05:\r\n                total_r += r\r\n                total_g += g\r\n                total_b += b\r\n                non_black_count += 1\r\n            \r\n            pixel_count += 1\r\n        \r\n        # If we found non-black pixels, use their average\r\n        if non_black_count &gt; 0:\r\n            return [total_r / non_black_count, total_g / non_black_count, total_b / non_black_count]\r\n        # Otherwise, use the average of all pixels\r\n        elif pixel_count &gt; 0:\r\n            return [total_r / pixel_count, total_g / pixel_count, total_b / pixel_count]\r\n        else:\r\n            return None\r\n\r\nclass VIEWPORT_OT_SelectDiffuseNodes(bpy.types.Operator):\r\n    bl_idname = \&quot;bst.select_diffuse_nodes\&quot;\r\n    bl_label = \&quot;Set Texture Display\&quot;\r\n    bl_description = \&quot;Select the most relevant diffuse/base color image texture node in each material\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n\r\n    def execute(self, context):\r\n        if select_diffuse_nodes:\r\n            select_diffuse_nodes()\r\n            self.report({&#39;INFO&#39;}, \&quot;Diffuse/BaseColor image nodes selected.\&quot;)\r\n        else:\r\n            self.report({&#39;ERROR&#39;}, \&quot;select_diffuse_nodes function not found.\&quot;)\r\n        return {&#39;FINISHED&#39;}\r\n\r\n# List of all classes in this module\r\nclasses = (\r\n    VIEWPORT_OT_SetViewportColors,\r\n    VIEW3D_PT_BulkViewportDisplay,\r\n    MATERIAL_OT_SelectInEditor,\r\n    VIEWPORT_OT_SelectDiffuseNodes,\r\n)\r\n\r\n# Registration\r\ndef register():\r\n    for cls in classes:\r\n        bpy.utils.register_class(cls)\r\n    \r\n    # Register properties\r\n    register_viewport_properties()\r\n\r\ndef unregister():\r\n    # Unregister properties\r\n    try:\r\n        unregister_viewport_properties()\r\n    except Exception:\r\n        pass\r\n    # Unregister classes\r\n    for cls in reversed(classes):\r\n        try:\r\n            bpy.utils.unregister_class(cls)\r\n        except RuntimeError:\r\n            pass &quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Adding new operator and cleaning properties**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;panels/bulk_viewport_display.py&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;daf2297c-bad6-427a-bfed-ac6c6b329b70&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;          global material_results, current_material, processed_count, total_materials, start_time, is_processing, material_queue, current_index\r\n          \r\n-         scene = context.scene\r\n-         \r\n-         if scene.viewport_colors_refresh_previews:\r\n-             try:\r\n-                 bpy.ops.wm.previews_clear()\r\n-                 bpy.ops.wm.previews_batch_generate()\r\n-                 bpy.ops.wm.previews_ensure()\r\n-             except Exception as exc:\r\n-                 self.report({&#39;WARNING&#39;}, f\&quot;Preview refresh failed: {exc}\&quot;)\r\n-         \r\n          # Reset global variables\r\n          material_results = {}\r&quot;,
        &quot;oldStart&quot;: 113,
        &quot;newStart&quot;: 113,
        &quot;oldLines&quot;: 14,
        &quot;newLines&quot;: 4,
        &quot;linesRemoved&quot;: 10
      },
      {
        &quot;diffString&quot;: &quot;          col = box.column(align=True)\r\n          col.prop(context.scene, \&quot;viewport_colors_selected_only\&quot;)\r\n-         col.prop(context.scene, \&quot;viewport_colors_refresh_previews\&quot;)\r\n+         col.operator(\&quot;bst.refresh_material_previews\&quot;, icon=&#39;FILE_REFRESH&#39;)\r\n          \r\n          # Add advanced options in a collapsible section\r&quot;,
        &quot;oldStart&quot;: 713,
        &quot;newStart&quot;: 703,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM panels/bulk_viewport_display.py&quot;,
  &quot;contentsAfterEdit&quot;: &quot;import bpy # type: ignore\r\nimport numpy as np\r\nfrom time import time\r\nimport os\r\nfrom enum import Enum\r\nimport colorsys  # Add colorsys for RGB to HSV conversion\r\nfrom ..ops.select_diffuse_nodes import select_diffuse_nodes  # Import the specific function\r\n\r\n# Material processing status enum\r\nclass MaterialStatus(Enum):\r\n    PENDING = 0\r\n    PROCESSING = 1\r\n    COMPLETED = 2\r\n    FAILED = 3\r\n    PREVIEW_BASED = 4\r\n\r\n# Global variables to store results and track progress\r\nmaterial_results = {}  # {material_name: (color, status)}\r\ncurrent_material = \&quot;\&quot;\r\nprocessed_count = 0\r\ntotal_materials = 0\r\nstart_time = 0\r\nis_processing = False\r\nmaterial_queue = []\r\ncurrent_index = 0\r\n\r\n# Scene properties for viewport display settings\r\ndef register_viewport_properties():\r\n    bpy.types.Scene.viewport_colors_selected_only = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Selected Objects Only\&quot;,\r\n        description=\&quot;Apply viewport colors only to materials in selected objects\&quot;,\r\n        default=False\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_batch_size = bpy.props.IntProperty(  # type: ignore\r\n        name=\&quot;Batch Size\&quot;,\r\n        description=\&quot;Number of materials to process in each batch\&quot;,\r\n        default=50,\r\n        min=1,\r\n        max=50\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_use_vectorized = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Use Vectorized Processing\&quot;,\r\n        description=\&quot;Use vectorized operations for image processing (faster but uses more memory)\&quot;,\r\n        default=True\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_darken_amount = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Color Adjustment\&quot;,\r\n        description=\&quot;Adjust viewport colors by ±10% (+1 = +10% lighter, 0 = no change, -1 = -10% darker)\&quot;,\r\n        default=0.0,\r\n        min=-1.0,\r\n        max=1.0,\r\n        subtype=&#39;FACTOR&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_value_amount = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Saturation Adjustment\&quot;,\r\n        description=\&quot;Adjust color saturation by ±10% (+1 = +10% more saturated, 0 = no change, -1 = -10% less saturated)\&quot;,\r\n        default=1.0,\r\n        min=-1.0,\r\n        max=1.0,\r\n        subtype=&#39;FACTOR&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_progress = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Progress\&quot;,\r\n        description=\&quot;Progress of the viewport color setting operation\&quot;,\r\n        default=0.0,\r\n        min=0.0,\r\n        max=100.0,\r\n        subtype=&#39;PERCENTAGE&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_show_advanced = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Show Advanced Options\&quot;,\r\n        description=\&quot;Show advanced options for viewport color extraction\&quot;,\r\n        default=False\r\n    )\r\n    \r\n    # New properties for thumbnail-based color extraction\r\n    bpy.types.Scene.viewport_colors_use_preview = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Use Material Thumbnails\&quot;,\r\n        description=\&quot;Use Blender&#39;s material thumbnails for color extraction (faster and more reliable)\&quot;,\r\n        default=True\r\n    )\r\n\r\n    bpy.types.Scene.show_material_results = bpy.props.BoolProperty(\r\n        name=\&quot;\&quot;,\r\n        description=\&quot;Show material results in the viewport display panel\&quot;,\r\n        default=True\r\n    )\r\n\r\ndef unregister_viewport_properties():\r\n    del bpy.types.Scene.viewport_colors_use_preview\r\n    del bpy.types.Scene.viewport_colors_batch_size\r\n    del bpy.types.Scene.viewport_colors_use_vectorized\r\n    del bpy.types.Scene.viewport_colors_darken_amount\r\n    del bpy.types.Scene.viewport_colors_value_amount\r\n    del bpy.types.Scene.viewport_colors_progress\r\n    del bpy.types.Scene.viewport_colors_selected_only\r\n    del bpy.types.Scene.viewport_colors_show_advanced\r\n    del bpy.types.Scene.show_material_results\r\n\r\nclass VIEWPORT_OT_SetViewportColors(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Set Viewport Display colors from BSDF base color or texture\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.set_viewport_colors\&quot;\r\n    bl_label = \&quot;Set Viewport Colors\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n    \r\n    def execute(self, context):\r\n        global material_results, current_material, processed_count, total_materials, start_time, is_processing, material_queue, current_index\r\n        \r\n        # Reset global variables\r\n        material_results = {}\r\n        current_material = \&quot;\&quot;\r\n        processed_count = 0\r\n        is_processing = True\r\n        start_time = time()\r\n        current_index = 0\r\n        \r\n        # Get materials based on selection mode\r\n        if context.scene.viewport_colors_selected_only:\r\n            # Get materials from selected objects only\r\n            materials = []\r\n            for obj in context.selected_objects:\r\n                if obj.type == &#39;MESH&#39; and obj.data.materials:\r\n                    for mat in obj.data.materials:\r\n                        if mat and not mat.is_grease_pencil and mat not in materials:\r\n                            materials.append(mat)\r\n        else:\r\n            # Get all materials in the scene\r\n            materials = [mat for mat in bpy.data.materials if not mat.is_grease_pencil]\r\n        \r\n        total_materials = len(materials)\r\n        material_queue = materials.copy()\r\n        \r\n        if total_materials == 0:\r\n            self.report({&#39;WARNING&#39;}, \&quot;No materials found to process\&quot;)\r\n            is_processing = False\r\n            return {&#39;CANCELLED&#39;}\r\n        \r\n        # Reset progress\r\n        context.scene.viewport_colors_progress = 0.0\r\n        \r\n        # Start a timer to process materials in batches\r\n        bpy.app.timers.register(self._process_batch)\r\n        \r\n        return {&#39;FINISHED&#39;}\r\n    \r\n    def _process_batch(self):\r\n        global material_results, current_material, processed_count, total_materials, is_processing, material_queue, current_index\r\n        \r\n        if not is_processing or len(material_queue) == 0:\r\n            is_processing = False\r\n            self.report_info()\r\n            return None\r\n        \r\n        # Get the batch size from scene properties\r\n        batch_size = bpy.context.scene.viewport_colors_batch_size\r\n        use_vectorized = bpy.context.scene.viewport_colors_use_vectorized\r\n        \r\n        # Process a batch of materials\r\n        batch_end = min(current_index + batch_size, len(material_queue))\r\n        batch = material_queue[current_index:batch_end]\r\n        \r\n        for material in batch:\r\n            # Skip if material is invalid or has been deleted\r\n            if material is None or material.name not in bpy.data.materials:\r\n                processed_count += 1\r\n                continue\r\n                \r\n            current_material = material.name\r\n            \r\n            # Process the material\r\n            color, status = process_material(material, use_vectorized)\r\n            \r\n            # Apply the color to the material\r\n            if color:\r\n                # Store the color change to apply later in main thread\r\n                material_results[material.name] = (color, status)\r\n                # Mark this material for color application\r\n                if not hasattr(self, &#39;pending_color_changes&#39;):\r\n                    self.pending_color_changes = []\r\n                self.pending_color_changes.append((material, color))\r\n            else:\r\n                # Store the result without color change\r\n                material_results[material.name] = (None, status)\r\n            \r\n            # Update processed count\r\n            processed_count += 1\r\n            \r\n            # Update progress\r\n            if total_materials &gt; 0:\r\n                bpy.context.scene.viewport_colors_progress = (processed_count / total_materials) * 100\r\n        \r\n        # Update the current index\r\n        current_index = batch_end\r\n        \r\n        # Force a redraw of the UI\r\n        for area in bpy.context.screen.areas:\r\n            area.tag_redraw()\r\n        \r\n        # Check if we&#39;re done\r\n        if current_index &gt;= len(material_queue):\r\n            is_processing = False\r\n            # Apply pending color changes in main thread\r\n            if hasattr(self, &#39;pending_color_changes&#39;) and self.pending_color_changes:\r\n                bpy.app.timers.register(self._apply_color_changes)\r\n            self.report_info()\r\n            return None\r\n        \r\n        # Continue processing\r\n        return 0.1  # Check again in 0.1 seconds\r\n    \r\n    def _apply_color_changes(self):\r\n        \&quot;\&quot;\&quot;Apply pending color changes in the main thread\&quot;\&quot;\&quot;\r\n        if not hasattr(self, &#39;pending_color_changes&#39;) or not self.pending_color_changes:\r\n            return None\r\n        \r\n        # Apply a batch of color changes\r\n        batch_size = 10  # Process 10 materials at a time\r\n        batch = self.pending_color_changes[:batch_size]\r\n        \r\n        for material, color in batch:\r\n            try:\r\n                if material and material.name in bpy.data.materials:\r\n                    material.diffuse_color = (*color, 1.0)\r\n            except Exception as e:\r\n                print(f\&quot;Could not set diffuse_color for {material.name if material else &#39;Unknown&#39;}: {e}\&quot;)\r\n        \r\n        # Remove processed items\r\n        self.pending_color_changes = self.pending_color_changes[batch_size:]\r\n        \r\n        # Continue if there are more to process\r\n        if self.pending_color_changes:\r\n            return 0.01  # Process next batch in 0.01 seconds\r\n        \r\n        # All done\r\n        print(f\&quot;Applied viewport colors to {len(batch)} materials\&quot;)\r\n        return None\r\n    \r\n    def report_info(self):\r\n        global processed_count, start_time\r\n        elapsed_time = time() - start_time\r\n        \r\n        # Count materials by status\r\n        preview_count = 0\r\n        node_count = 0\r\n        failed_count = 0\r\n        \r\n        for _, status in material_results.values():\r\n            if status == MaterialStatus.PREVIEW_BASED:\r\n                preview_count += 1\r\n            elif status == MaterialStatus.COMPLETED:\r\n                node_count += 1\r\n            elif status == MaterialStatus.FAILED:\r\n                failed_count += 1\r\n        \r\n        # Use a popup menu instead of self.report since this might be called from a timer\r\n        def draw_popup(self, context):\r\n            self.layout.label(text=f\&quot;Processed {processed_count} materials in {elapsed_time:.2f} seconds\&quot;)\r\n            self.layout.label(text=f\&quot;Thumbnail-based: {preview_count}, Node-based: {node_count}\&quot;)\r\n            self.layout.label(text=f\&quot;Failed: {failed_count}\&quot;)\r\n        \r\n        bpy.context.window_manager.popup_menu(draw_popup, title=\&quot;Processing Complete\&quot;, icon=&#39;INFO&#39;)\r\n\r\ndef correct_viewport_color(color):\r\n    \&quot;\&quot;\&quot;Adjust viewport colors by color intensity and saturation\&quot;\&quot;\&quot;\r\n    r, g, b = color\r\n    \r\n    # Get the color adjustment amount (-1 to +1) and scale it to ±10%\r\n    color_adjustment = bpy.context.scene.viewport_colors_darken_amount * 0.1\r\n    \r\n    # Get the saturation adjustment amount (-1 to +1) and scale it to ±10%\r\n    saturation_adjustment = bpy.context.scene.viewport_colors_value_amount * 0.1\r\n    \r\n    # First apply the color adjustment (RGB)\r\n    r = r + color_adjustment\r\n    g = g + color_adjustment\r\n    b = b + color_adjustment\r\n    \r\n    # Clamp RGB values after color adjustment\r\n    r = max(0.0, min(1.0, r))\r\n    g = max(0.0, min(1.0, g))\r\n    b = max(0.0, min(1.0, b))\r\n    \r\n    # Then apply the saturation adjustment using HSV\r\n    if saturation_adjustment != 0:\r\n        # Convert to HSV\r\n        h, s, v = colorsys.rgb_to_hsv(r, g, b)\r\n        \r\n        # Adjust saturation while preserving hue and value\r\n        s = s + saturation_adjustment\r\n        s = max(0.0, min(1.0, s))\r\n        \r\n        # Convert back to RGB\r\n        r, g, b = colorsys.hsv_to_rgb(h, s, v)\r\n    \r\n    return (r, g, b)\r\n\r\ndef process_material(material, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Process a material to determine its viewport color\&quot;\&quot;\&quot;\r\n    if not material:\r\n        print(f\&quot;Material is None, using fallback color\&quot;)\r\n        return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n    \r\n    if material.is_grease_pencil:\r\n        print(f\&quot;Material {material.name}: is a grease pencil material, using fallback color\&quot;)\r\n        return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n    \r\n    try:\r\n        # Get color from material thumbnail\r\n        print(f\&quot;Material {material.name}: Attempting to extract color from thumbnail\&quot;)\r\n        \r\n        # Get color from the material thumbnail\r\n        color = get_color_from_preview(material, use_vectorized)\r\n        \r\n        if color:\r\n            print(f\&quot;Material {material.name}: Thumbnail color = {color}\&quot;)\r\n            \r\n            # Correct color for viewport display\r\n            corrected_color = correct_viewport_color(color)\r\n            print(f\&quot;Material {material.name}: Corrected thumbnail color = {corrected_color}\&quot;)\r\n            \r\n            return corrected_color, MaterialStatus.PREVIEW_BASED\r\n        else:\r\n            print(f\&quot;Material {material.name}: Could not extract color from thumbnail, using fallback color\&quot;)\r\n            return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n        \r\n    except Exception as e:\r\n        print(f\&quot;Error processing material {material.name}: {e}\&quot;)\r\n        return (1, 1, 1), MaterialStatus.FAILED\r\n\r\ndef get_average_color(image, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Calculate the average color of an image\&quot;\&quot;\&quot;\r\n    if not image or not image.has_data:\r\n        return None\r\n    \r\n    # Get image pixels\r\n    pixels = list(image.pixels)\r\n    \r\n    if use_vectorized and np is not None:\r\n        # Use NumPy for faster processing\r\n        pixels_np = np.array(pixels)\r\n        \r\n        # Reshape to RGBA format\r\n        pixels_np = pixels_np.reshape(-1, 4)\r\n        \r\n        # Calculate average color (ignoring alpha)\r\n        avg_color = pixels_np[:, :3].mean(axis=0)\r\n        \r\n        return avg_color.tolist()\r\n    else:\r\n        # Fallback to pure Python\r\n        total_r, total_g, total_b = 0, 0, 0\r\n        pixel_count = len(pixels) // 4\r\n        \r\n        for i in range(0, len(pixels), 4):\r\n            total_r += pixels[i]\r\n            total_g += pixels[i+1]\r\n            total_b += pixels[i+2]\r\n        \r\n        if pixel_count &gt; 0:\r\n            return [total_r / pixel_count, total_g / pixel_count, total_b / pixel_count]\r\n        else:\r\n            return None\r\n\r\ndef find_image_node(node, visited=None):\r\n    \&quot;\&quot;\&quot;Find the first image node connected to the given node\&quot;\&quot;\&quot;\r\n    if visited is None:\r\n        visited = set()\r\n    \r\n    if node in visited:\r\n        return None\r\n    \r\n    visited.add(node)\r\n    \r\n    # Check if this is an image node\r\n    if node.type == &#39;TEX_IMAGE&#39; and node.image:\r\n        return node\r\n    \r\n    # Check input connections\r\n    for input_socket in node.inputs:\r\n        for link in input_socket.links:\r\n            from_node = link.from_node\r\n            result = find_image_node(from_node, visited)\r\n            if result:\r\n                return result\r\n    \r\n    return None\r\n\r\ndef find_color_source(node, socket_name=None, visited=None):\r\n    \&quot;\&quot;\&quot;\r\n    Recursively trace color data through nodes to find the source\r\n    This is an enhanced version that handles mix nodes and node groups\r\n    \&quot;\&quot;\&quot;\r\n    if visited is None:\r\n        visited = set()\r\n    \r\n    # Avoid infinite recursion\r\n    node_id = (node, socket_name)\r\n    if node_id in visited:\r\n        return None, None\r\n    \r\n    visited.add(node_id)\r\n    \r\n    # Handle different node types\r\n    if node.type == &#39;TEX_IMAGE&#39; and node.image:\r\n        # Direct image texture\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;RGB&#39;:\r\n        # Direct RGB color\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;VALTORGB&#39;:  # Color Ramp\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;MIX_RGB&#39; or node.type == &#39;MIX&#39;:\r\n        # For mix nodes, check the factor to determine which input to prioritize\r\n        factor = 0.5  # Default to equal mix\r\n        \r\n        # Try to get the factor value\r\n        if len(node.inputs) &gt;= 1:\r\n            if hasattr(node.inputs[0], &#39;default_value&#39;):\r\n                factor = node.inputs[0].default_value\r\n        \r\n        # If factor is close to 0, prioritize the first color input\r\n        # If factor is close to 1, prioritize the second color input\r\n        # Otherwise, check both with second having slightly higher priority\r\n        \r\n        if factor &lt; 0.1:  # Strongly favor first input\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n            # Fallback to second input\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n        elif factor &gt; 0.9:  # Strongly favor second input\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n            # Fallback to first input\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n        else:\r\n            # Check both inputs with slight preference for the second input (usually the main color)\r\n            # First try Color2 (second input)\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n            \r\n            # Then try Color1 (first input)\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n    \r\n    elif node.type == &#39;GROUP&#39;:\r\n        # Handle node groups by finding the group output node and tracing back\r\n        if node.node_tree:\r\n            # Find output node in the group\r\n            for group_node in node.node_tree.nodes:\r\n                if group_node.type == &#39;GROUP_OUTPUT&#39;:\r\n                    # Find which input socket corresponds to the color output\r\n                    for i, output in enumerate(node.outputs):\r\n                        if output.links and (socket_name is None or output.name == socket_name):\r\n                            # Find the corresponding input in the group output node\r\n                            if i &lt; len(group_node.inputs) and group_node.inputs[i].links:\r\n                                input_link = group_node.inputs[i].links[0]\r\n                                source_node = input_link.from_node\r\n                                source_socket = input_link.from_socket.name\r\n                                return find_color_source(source_node, source_socket, visited)\r\n    \r\n    elif node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n        # If we somehow got to a principled BSDF node, check its base color input\r\n        base_color_input = node.inputs.get(&#39;Base Color&#39;)\r\n        if base_color_input and base_color_input.links:\r\n            connected_node = base_color_input.links[0].from_node\r\n            return find_color_source(connected_node, None, visited)\r\n    \r\n    # For shader nodes, try to find color inputs\r\n    elif &#39;BSDF&#39; in node.type or &#39;SHADER&#39; in node.type:\r\n        # Look for color inputs in shader nodes\r\n        color_input_names = [&#39;Color&#39;, &#39;Base Color&#39;, &#39;Diffuse Color&#39;, &#39;Tint&#39;]\r\n        for name in color_input_names:\r\n            input_socket = node.inputs.get(name)\r\n            if input_socket and input_socket.links:\r\n                connected_node = input_socket.links[0].from_node\r\n                result_node, result_socket = find_color_source(connected_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n    \r\n    # For other node types, check all inputs\r\n    for input_socket in node.inputs:\r\n        if input_socket.links:\r\n            from_node = input_socket.links[0].from_node\r\n            result_node, result_socket = find_color_source(from_node, None, visited)\r\n            if result_node:\r\n                return result_node, result_socket\r\n    \r\n    # If we get here, no color source was found\r\n    return None, None\r\n\r\ndef get_final_color(material):\r\n    \&quot;\&quot;\&quot;Get the final color for a material\&quot;\&quot;\&quot;\r\n    if not material or not material.use_nodes:\r\n        print(f\&quot;Material {material.name if material else &#39;None&#39;} has no nodes\&quot;)\r\n        return None\r\n    \r\n    # Find the Principled BSDF node\r\n    principled_node = None\r\n    for node in material.node_tree.nodes:\r\n        if node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n            principled_node = node\r\n            break\r\n    \r\n    if not principled_node:\r\n        print(f\&quot;Material {material.name}: No Principled BSDF node found\&quot;)\r\n        return None\r\n    \r\n    # Get the Base Color input\r\n    base_color_input = principled_node.inputs.get(&#39;Base Color&#39;)\r\n    if not base_color_input:\r\n        print(f\&quot;Material {material.name}: No Base Color input found\&quot;)\r\n        return None\r\n    \r\n    # Check if there&#39;s a texture connected to the Base Color input\r\n    if base_color_input.links:\r\n        connected_node = base_color_input.links[0].from_node\r\n        print(f\&quot;Material {material.name}: Base Color connected to {connected_node.name} of type {connected_node.type}\&quot;)\r\n        \r\n        # Use the enhanced color source finding function\r\n        source_node, source_socket = find_color_source(connected_node)\r\n        \r\n        if source_node:\r\n            print(f\&quot;Material {material.name}: Found color source node {source_node.name} of type {source_node.type}\&quot;)\r\n            \r\n            # Handle different source node types\r\n            if source_node.type == &#39;TEX_IMAGE&#39; and source_node.image:\r\n                print(f\&quot;Material {material.name}: Using image texture {source_node.image.name}\&quot;)\r\n                color = get_average_color(source_node.image)\r\n                if color:\r\n                    print(f\&quot;Material {material.name}: Image average color = {color}\&quot;)\r\n                    return color\r\n                else:\r\n                    print(f\&quot;Material {material.name}: Could not calculate image average color\&quot;)\r\n            \r\n            # If it&#39;s a color ramp, get the average color from the ramp\r\n            elif source_node.type == &#39;VALTORGB&#39;:  # Color Ramp node\r\n                print(f\&quot;Material {material.name}: Using color ramp\&quot;)\r\n                # Get the average of the color stops\r\n                elements = source_node.color_ramp.elements\r\n                if elements:\r\n                    avg_color = [0, 0, 0]\r\n                    for element in elements:\r\n                        color = element.color[:3]  # Ignore alpha\r\n                        avg_color[0] += color[0]\r\n                        avg_color[1] += color[1]\r\n                        avg_color[2] += color[2]\r\n                    \r\n                    avg_color[0] /= len(elements)\r\n                    avg_color[1] /= len(elements)\r\n                    avg_color[2] /= len(elements)\r\n                    \r\n                    print(f\&quot;Material {material.name}: Color ramp average = {avg_color}\&quot;)\r\n                    return avg_color\r\n            \r\n            # If it&#39;s an RGB node, use its color\r\n            elif source_node.type == &#39;RGB&#39;:\r\n                color = list(source_node.outputs[0].default_value)[:3]\r\n                print(f\&quot;Material {material.name}: RGB node color = {color}\&quot;)\r\n                return color\r\n            \r\n            # For other node types, try to get color from the output socket\r\n            elif source_socket and hasattr(source_node.outputs, &#39;__getitem__&#39;):\r\n                for output in source_node.outputs:\r\n                    if output.name == source_socket:\r\n                        if hasattr(output, &#39;default_value&#39;) and len(output.default_value) &gt;= 3:\r\n                            color = list(output.default_value)[:3]\r\n                            print(f\&quot;Material {material.name}: Node output socket color = {color}\&quot;)\r\n                            return color\r\n            \r\n            print(f\&quot;Material {material.name}: Could not extract color from source node {source_node.name} of type {source_node.type}\&quot;)\r\n        else:\r\n            print(f\&quot;Material {material.name}: Could not find color source node in the node tree\&quot;)\r\n            \r\n            # Debug: Print the node tree structure to help diagnose the issue\r\n            print(f\&quot;Material {material.name}: Node tree structure:\&quot;)\r\n            for node in material.node_tree.nodes:\r\n                print(f\&quot;  - Node: {node.name}, Type: {node.type}\&quot;)\r\n                for input_socket in node.inputs:\r\n                    if input_socket.links:\r\n                        print(f\&quot;    - Input: {input_socket.name} connected to {input_socket.links[0].from_node.name}\&quot;)\r\n    \r\n    # If no texture or couldn&#39;t get texture color, use the base color value\r\n    color = list(base_color_input.default_value)[:3]\r\n    print(f\&quot;Material {material.name}: Using base color value = {color}\&quot;)\r\n    return color\r\n\r\ndef find_diffuse_texture(material):\r\n    \&quot;\&quot;\&quot;Find the diffuse texture in a material\&quot;\&quot;\&quot;\r\n    if not material or not material.use_nodes:\r\n        return None\r\n    \r\n    # Find the principled BSDF node\r\n    principled_node = None\r\n    for node in material.node_tree.nodes:\r\n        if node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n            principled_node = node\r\n            break\r\n    \r\n    if not principled_node:\r\n        return None\r\n    \r\n    # Find the base color input\r\n    base_color_input = principled_node.inputs.get(&#39;Base Color&#39;)\r\n    if not base_color_input or not base_color_input.links:\r\n        return None\r\n    \r\n    # Get the connected node\r\n    connected_node = base_color_input.links[0].from_node\r\n    \r\n    # Use the enhanced color source finding function\r\n    source_node, _ = find_color_source(connected_node)\r\n    \r\n    # Check if we found an image texture\r\n    if source_node and source_node.type == &#39;TEX_IMAGE&#39; and source_node.image:\r\n        return source_node.image\r\n    \r\n    return None\r\n\r\ndef get_status_icon(status):\r\n    \&quot;\&quot;\&quot;Get the icon for a material status\&quot;\&quot;\&quot;\r\n    if status == MaterialStatus.PENDING:\r\n        return &#39;TRIA_RIGHT&#39;\r\n    elif status == MaterialStatus.PROCESSING:\r\n        return &#39;SORTTIME&#39;\r\n    elif status == MaterialStatus.COMPLETED:\r\n        return &#39;CHECKMARK&#39;\r\n    elif status == MaterialStatus.PREVIEW_BASED:\r\n        return &#39;IMAGE_DATA&#39;\r\n    elif status == MaterialStatus.FAILED:\r\n        return &#39;ERROR&#39;\r\n    else:\r\n        return &#39;QUESTION&#39;\r\n\r\ndef get_status_text(status):\r\n    \&quot;\&quot;\&quot;Get the text for a material status\&quot;\&quot;\&quot;\r\n    if status == MaterialStatus.PENDING:\r\n        return \&quot;Pending\&quot;\r\n    elif status == MaterialStatus.PROCESSING:\r\n        return \&quot;Processing\&quot;\r\n    elif status == MaterialStatus.COMPLETED:\r\n        return \&quot;Node-based\&quot;\r\n    elif status == MaterialStatus.PREVIEW_BASED:\r\n        return \&quot;Thumbnail-based\&quot;\r\n    elif status == MaterialStatus.FAILED:\r\n        return \&quot;Failed\&quot;\r\n    else:\r\n        return \&quot;Unknown\&quot;\r\n\r\nclass VIEW3D_PT_BulkViewportDisplay(bpy.types.Panel):\r\n    \&quot;\&quot;\&quot;Bulk Viewport Display Panel\&quot;\&quot;\&quot;\r\n    bl_label = \&quot;Bulk Viewport Display\&quot;\r\n    bl_idname = \&quot;VIEW3D_PT_bulk_viewport_display\&quot;\r\n    bl_space_type = &#39;VIEW_3D&#39;\r\n    bl_region_type = &#39;UI&#39;\r\n    bl_category = &#39;Edit&#39;\r\n    bl_parent_id = \&quot;VIEW3D_PT_bulk_scene_tools\&quot;\r\n    bl_order = 3\r\n    \r\n    def draw(self, context):\r\n        layout = self.layout\r\n        \r\n        # Viewport Colors section\r\n        box = layout.box()\r\n        box.label(text=\&quot;Viewport Colors\&quot;)\r\n        \r\n        # Add description\r\n        col = box.column()\r\n        col.label(text=\&quot;Set viewport colors from material thumbnails\&quot;)\r\n        \r\n        # Add primary settings\r\n        col = box.column(align=True)\r\n        col.prop(context.scene, \&quot;viewport_colors_selected_only\&quot;)\r\n        col.operator(\&quot;bst.refresh_material_previews\&quot;, icon=&#39;FILE_REFRESH&#39;)\r\n        \r\n        # Add advanced options in a collapsible section\r\n        row = box.row()\r\n        row.prop(context.scene, \&quot;viewport_colors_show_advanced\&quot;, \r\n                 icon=&#39;DISCLOSURE_TRI_DOWN&#39; if context.scene.viewport_colors_show_advanced else &#39;DISCLOSURE_TRI_RIGHT&#39;,\r\n                 emboss=False)\r\n        row.label(text=\&quot;Advanced Options\&quot;)\r\n        \r\n        if context.scene.viewport_colors_show_advanced:\r\n            adv_col = box.column(align=True)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_batch_size\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_use_vectorized\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_darken_amount\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_value_amount\&quot;)\r\n        \r\n        # Add the operator button\r\n        row = box.row()\r\n        row.scale_y = 1.5\r\n        row.operator(\&quot;bst.set_viewport_colors\&quot;)\r\n        \r\n        # Show progress if processing\r\n        if is_processing:\r\n            row = box.row()\r\n            row.label(text=f\&quot;Processing: {processed_count}/{total_materials}\&quot;)\r\n            \r\n            # Add a progress bar\r\n            row = box.row()\r\n            row.prop(context.scene, \&quot;viewport_colors_progress\&quot;, text=\&quot;\&quot;)\r\n        \r\n        # Show material results if available\r\n        if material_results:\r\n            box.separator()\r\n            row = box.row()\r\n            row.prop(context.scene, \&quot;show_material_results\&quot;, \r\n                     icon=&#39;DISCLOSURE_TRI_DOWN&#39; if context.scene.show_material_results else &#39;DISCLOSURE_TRI_RIGHT&#39;,\r\n                     emboss=False)\r\n            row.label(text=\&quot;Material Results:\&quot;)\r\n            if context.scene.show_material_results:\r\n                # Create a scrollable list\r\n                material_box = box.box()\r\n                row = material_box.row()\r\n                col = row.column()\r\n                \r\n                # Collect materials to remove\r\n                materials_to_remove = []\r\n                \r\n                # Count materials by status\r\n                preview_count = 0\r\n                failed_count = 0\r\n                \r\n                # Display material results - use a copy of the keys to avoid modification during iteration\r\n                for material_name in list(material_results.keys()):\r\n                    color, status = material_results[material_name]\r\n                    \r\n                    # Update counts\r\n                    if status == MaterialStatus.PREVIEW_BASED:\r\n                        preview_count += 1\r\n                    elif status == MaterialStatus.FAILED:\r\n                        failed_count += 1\r\n                    \r\n                    row = col.row(align=True)\r\n                    \r\n                    # Add status icon\r\n                    row.label(text=\&quot;\&quot;, icon=get_status_icon(status))\r\n                    \r\n                    # Add material name with operator to select it\r\n                    op = row.operator(\&quot;bst.select_in_editor\&quot;, text=material_name)\r\n                    op.material_name = material_name\r\n                    \r\n                    # Add color preview\r\n                    if color:\r\n                        material = bpy.data.materials.get(material_name)\r\n                        if material:  # Check if material still exists\r\n                            row.prop(material, \&quot;diffuse_color\&quot;, text=\&quot;\&quot;)\r\n                        else:\r\n                            # Material no longer exists, show a placeholder color\r\n                            row.label(text=\&quot;\&quot;, icon=&#39;ERROR&#39;)\r\n                            # Mark for removal\r\n                            materials_to_remove.append(material_name)\r\n                \r\n                # Remove materials that no longer exist\r\n                for material_name in materials_to_remove:\r\n                    material_results.pop(material_name, None)\r\n                \r\n                # Show statistics\r\n                if len(material_results) &gt; 0:\r\n                    material_box.separator()\r\n                    stats_col = material_box.column(align=True)\r\n                    stats_col.label(text=f\&quot;Total: {len(material_results)} materials\&quot;)\r\n                    stats_col.label(text=f\&quot;Thumbnail-based: {preview_count}\&quot;)\r\n                    stats_col.label(text=f\&quot;Failed: {failed_count}\&quot;)\r\n\r\n        # Add the select diffuse nodes button at the bottom\r\n        layout.separator()\r\n        layout.operator(\&quot;bst.select_diffuse_nodes\&quot;, icon=&#39;NODE_TEXTURE&#39;)\r\n\r\nclass MATERIAL_OT_SelectInEditor(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Select this material in the editor\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.select_in_editor\&quot;\r\n    bl_label = \&quot;Select Material\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n    \r\n    material_name: bpy.props.StringProperty(  # type: ignore\r\n        name=\&quot;Material Name\&quot;,\r\n        description=\&quot;Name of the material to select\&quot;,\r\n        default=\&quot;\&quot;\r\n    )\r\n    \r\n    def execute(self, context):\r\n        # Find the material\r\n        material = bpy.data.materials.get(self.material_name)\r\n        if not material:\r\n            # Remove this entry from material_results to avoid future errors\r\n            if self.material_name in material_results:\r\n                material_results.pop(self.material_name, None)\r\n                # Force a redraw of the UI\r\n                for area in context.screen.areas:\r\n                    area.tag_redraw()\r\n            self.report({&#39;ERROR&#39;}, f\&quot;Material &#39;{self.material_name}&#39; not found\&quot;)\r\n            return {&#39;CANCELLED&#39;}\r\n        \r\n        # Find an object using this material\r\n        for obj in bpy.data.objects:\r\n            if obj.type == &#39;MESH&#39; and obj.data.materials:\r\n                for i, mat in enumerate(obj.data.materials):\r\n                    if mat == material:\r\n                        # Select the object\r\n                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)\r\n                        obj.select_set(True)\r\n                        context.view_layer.objects.active = obj\r\n                        \r\n                        # Set the active material index\r\n                        obj.active_material_index = i\r\n                        \r\n                        # Switch to material properties\r\n                        for area in context.screen.areas:\r\n                            if area.type == &#39;PROPERTIES&#39;:\r\n                                for space in area.spaces:\r\n                                    if space.type == &#39;PROPERTIES&#39;:\r\n                                        space.context = &#39;MATERIAL&#39;\r\n                        \r\n                        return {&#39;FINISHED&#39;}\r\n        \r\n        self.report({&#39;WARNING&#39;}, f\&quot;No object using material &#39;{self.material_name}&#39; found\&quot;)\r\n        return {&#39;CANCELLED&#39;}\r\n\r\ndef get_color_from_preview(material, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Extract the average color from a material thumbnail\&quot;\&quot;\&quot;\r\n    if not material:\r\n        return None\r\n    \r\n    # Force Blender to generate the material preview if it doesn&#39;t exist\r\n    # This uses Blender&#39;s internal preview generation system\r\n    preview = material.preview\r\n    if not preview:\r\n        return None\r\n    \r\n    # Ensure the preview is generated (this should be very fast as Blender maintains these)\r\n    if preview.icon_id == 0:\r\n        # Use Blender&#39;s standard preview size\r\n        preview.icon_size = (128, 128)\r\n        # This triggers Blender&#39;s internal preview generation\r\n        icon_id = preview.icon_id  # Store in variable instead of just accessing\r\n    \r\n    # Access the preview image data - these are the same thumbnails shown in the material panel\r\n    preview_image = preview.icon_pixels_float\r\n    \r\n    if not preview_image or len(preview_image) == 0:\r\n        return None\r\n    \r\n    if use_vectorized and np is not None:\r\n        # Use NumPy for faster processing\r\n        pixels_np = np.array(preview_image)\r\n        \r\n        # Reshape to RGBA format (preview is stored as a flat RGBA array)\r\n        pixels_np = pixels_np.reshape(-1, 4)\r\n        \r\n        # Calculate average color (ignoring alpha and any pure black pixels which are often the background)\r\n        # Filter out black pixels (background) by checking if R+G+B is very small\r\n        non_black_mask = np.sum(pixels_np[:, :3], axis=1) &gt; 0.05\r\n        \r\n        if np.any(non_black_mask):\r\n            # Only use non-black pixels for the average\r\n            avg_color = pixels_np[non_black_mask][:, :3].mean(axis=0)\r\n            return avg_color.tolist()\r\n        else:\r\n            # If all pixels are black, return the average of all pixels\r\n            avg_color = pixels_np[:, :3].mean(axis=0)\r\n            return avg_color.tolist()\r\n    else:\r\n        # Fallback to pure Python\r\n        total_r, total_g, total_b = 0, 0, 0\r\n        pixel_count = 0\r\n        non_black_count = 0\r\n        \r\n        # Process pixels in groups of 4 (RGBA)\r\n        for i in range(0, len(preview_image), 4):\r\n            r, g, b, a = preview_image[i:i+4]\r\n            \r\n            # Skip black pixels (background)\r\n            if r + g + b &gt; 0.05:\r\n                total_r += r\r\n                total_g += g\r\n                total_b += b\r\n                non_black_count += 1\r\n            \r\n            pixel_count += 1\r\n        \r\n        # If we found non-black pixels, use their average\r\n        if non_black_count &gt; 0:\r\n            return [total_r / non_black_count, total_g / non_black_count, total_b / non_black_count]\r\n        # Otherwise, use the average of all pixels\r\n        elif pixel_count &gt; 0:\r\n            return [total_r / pixel_count, total_g / pixel_count, total_b / pixel_count]\r\n        else:\r\n            return None\r\n\r\nclass VIEWPORT_OT_SelectDiffuseNodes(bpy.types.Operator):\r\n    bl_idname = \&quot;bst.select_diffuse_nodes\&quot;\r\n    bl_label = \&quot;Set Texture Display\&quot;\r\n    bl_description = \&quot;Select the most relevant diffuse/base color image texture node in each material\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n\r\n    def execute(self, context):\r\n        if select_diffuse_nodes:\r\n            select_diffuse_nodes()\r\n            self.report({&#39;INFO&#39;}, \&quot;Diffuse/BaseColor image nodes selected.\&quot;)\r\n        else:\r\n            self.report({&#39;ERROR&#39;}, \&quot;select_diffuse_nodes function not found.\&quot;)\r\n        return {&#39;FINISHED&#39;}\r\n\r\n# List of all classes in this module\r\nclasses = (\r\n    VIEWPORT_OT_SetViewportColors,\r\n    VIEW3D_PT_BulkViewportDisplay,\r\n    MATERIAL_OT_SelectInEditor,\r\n    VIEWPORT_OT_SelectDiffuseNodes,\r\n)\r\n\r\n# Registration\r\ndef register():\r\n    for cls in classes:\r\n        bpy.utils.register_class(cls)\r\n    \r\n    # Register properties\r\n    register_viewport_properties()\r\n\r\ndef unregister():\r\n    # Unregister properties\r\n    try:\r\n        unregister_viewport_properties()\r\n    except Exception:\r\n        pass\r\n    # Unregister classes\r\n    for cls in reversed(classes):\r\n        try:\r\n            bpy.utils.unregister_class(cls)\r\n        except RuntimeError:\r\n            pass &quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Adding operator classes and registration**</details></think>

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>
**Verifying context lines for patching**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: panels/bulk_viewport_display.py</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing to insert operator class**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;panels/bulk_viewport_display.py&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;10a84842-e603-4d47-b4a3-9e2fd27751cb&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;          bpy.context.window_manager.popup_menu(draw_popup, title=\&quot;Processing Complete\&quot;, icon=&#39;INFO&#39;)\r\n  \r\n+ \r\n+ class VIEWPORT_OT_RefreshMaterialPreviews(bpy.types.Operator):\r\n+     \&quot;\&quot;\&quot;Regenerate material previews to avoid stale thumbnails\&quot;\&quot;\&quot;\r\n+     bl_idname = \&quot;bst.refresh_material_previews\&quot;\r\n+     bl_label = \&quot;Refresh Material Previews\&quot;\r\n+     bl_options = {&#39;REGISTER&#39;}\r\n+ \r\n+     def execute(self, context):\r\n+         try:\r\n+             bpy.ops.wm.previews_clear()\r\n+             bpy.ops.wm.previews_batch_generate()\r\n+             bpy.ops.wm.previews_ensure()\r\n+         except Exception as exc:\r\n+             self.report({&#39;WARNING&#39;}, f\&quot;Preview refresh failed: {exc}\&quot;)\r\n+             return {&#39;CANCELLED&#39;}\r\n+ \r\n+         self.report({&#39;INFO&#39;}, \&quot;Material previews refreshed\&quot;)\r\n+         return {&#39;FINISHED&#39;}\r\n+ \r\n+ \r\n  def correct_viewport_color(color):\r\n      \&quot;\&quot;\&quot;Adjust viewport colors by color intensity and saturation\&quot;\&quot;\&quot;\r&quot;,
        &quot;oldStart&quot;: 267,
        &quot;newStart&quot;: 267,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 24,
        &quot;linesAdded&quot;: 20
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM panels/bulk_viewport_display.py&quot;,
  &quot;contentsAfterEdit&quot;: &quot;import bpy # type: ignore\r\nimport numpy as np\r\nfrom time import time\r\nimport os\r\nfrom enum import Enum\r\nimport colorsys  # Add colorsys for RGB to HSV conversion\r\nfrom ..ops.select_diffuse_nodes import select_diffuse_nodes  # Import the specific function\r\n\r\n# Material processing status enum\r\nclass MaterialStatus(Enum):\r\n    PENDING = 0\r\n    PROCESSING = 1\r\n    COMPLETED = 2\r\n    FAILED = 3\r\n    PREVIEW_BASED = 4\r\n\r\n# Global variables to store results and track progress\r\nmaterial_results = {}  # {material_name: (color, status)}\r\ncurrent_material = \&quot;\&quot;\r\nprocessed_count = 0\r\ntotal_materials = 0\r\nstart_time = 0\r\nis_processing = False\r\nmaterial_queue = []\r\ncurrent_index = 0\r\n\r\n# Scene properties for viewport display settings\r\ndef register_viewport_properties():\r\n    bpy.types.Scene.viewport_colors_selected_only = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Selected Objects Only\&quot;,\r\n        description=\&quot;Apply viewport colors only to materials in selected objects\&quot;,\r\n        default=False\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_batch_size = bpy.props.IntProperty(  # type: ignore\r\n        name=\&quot;Batch Size\&quot;,\r\n        description=\&quot;Number of materials to process in each batch\&quot;,\r\n        default=50,\r\n        min=1,\r\n        max=50\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_use_vectorized = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Use Vectorized Processing\&quot;,\r\n        description=\&quot;Use vectorized operations for image processing (faster but uses more memory)\&quot;,\r\n        default=True\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_darken_amount = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Color Adjustment\&quot;,\r\n        description=\&quot;Adjust viewport colors by ±10% (+1 = +10% lighter, 0 = no change, -1 = -10% darker)\&quot;,\r\n        default=0.0,\r\n        min=-1.0,\r\n        max=1.0,\r\n        subtype=&#39;FACTOR&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_value_amount = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Saturation Adjustment\&quot;,\r\n        description=\&quot;Adjust color saturation by ±10% (+1 = +10% more saturated, 0 = no change, -1 = -10% less saturated)\&quot;,\r\n        default=1.0,\r\n        min=-1.0,\r\n        max=1.0,\r\n        subtype=&#39;FACTOR&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_progress = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Progress\&quot;,\r\n        description=\&quot;Progress of the viewport color setting operation\&quot;,\r\n        default=0.0,\r\n        min=0.0,\r\n        max=100.0,\r\n        subtype=&#39;PERCENTAGE&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_show_advanced = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Show Advanced Options\&quot;,\r\n        description=\&quot;Show advanced options for viewport color extraction\&quot;,\r\n        default=False\r\n    )\r\n    \r\n    # New properties for thumbnail-based color extraction\r\n    bpy.types.Scene.viewport_colors_use_preview = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Use Material Thumbnails\&quot;,\r\n        description=\&quot;Use Blender&#39;s material thumbnails for color extraction (faster and more reliable)\&quot;,\r\n        default=True\r\n    )\r\n\r\n    bpy.types.Scene.show_material_results = bpy.props.BoolProperty(\r\n        name=\&quot;\&quot;,\r\n        description=\&quot;Show material results in the viewport display panel\&quot;,\r\n        default=True\r\n    )\r\n\r\ndef unregister_viewport_properties():\r\n    del bpy.types.Scene.viewport_colors_use_preview\r\n    del bpy.types.Scene.viewport_colors_batch_size\r\n    del bpy.types.Scene.viewport_colors_use_vectorized\r\n    del bpy.types.Scene.viewport_colors_darken_amount\r\n    del bpy.types.Scene.viewport_colors_value_amount\r\n    del bpy.types.Scene.viewport_colors_progress\r\n    del bpy.types.Scene.viewport_colors_selected_only\r\n    del bpy.types.Scene.viewport_colors_show_advanced\r\n    del bpy.types.Scene.show_material_results\r\n\r\nclass VIEWPORT_OT_SetViewportColors(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Set Viewport Display colors from BSDF base color or texture\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.set_viewport_colors\&quot;\r\n    bl_label = \&quot;Set Viewport Colors\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n    \r\n    def execute(self, context):\r\n        global material_results, current_material, processed_count, total_materials, start_time, is_processing, material_queue, current_index\r\n        \r\n        # Reset global variables\r\n        material_results = {}\r\n        current_material = \&quot;\&quot;\r\n        processed_count = 0\r\n        is_processing = True\r\n        start_time = time()\r\n        current_index = 0\r\n        \r\n        # Get materials based on selection mode\r\n        if context.scene.viewport_colors_selected_only:\r\n            # Get materials from selected objects only\r\n            materials = []\r\n            for obj in context.selected_objects:\r\n                if obj.type == &#39;MESH&#39; and obj.data.materials:\r\n                    for mat in obj.data.materials:\r\n                        if mat and not mat.is_grease_pencil and mat not in materials:\r\n                            materials.append(mat)\r\n        else:\r\n            # Get all materials in the scene\r\n            materials = [mat for mat in bpy.data.materials if not mat.is_grease_pencil]\r\n        \r\n        total_materials = len(materials)\r\n        material_queue = materials.copy()\r\n        \r\n        if total_materials == 0:\r\n            self.report({&#39;WARNING&#39;}, \&quot;No materials found to process\&quot;)\r\n            is_processing = False\r\n            return {&#39;CANCELLED&#39;}\r\n        \r\n        # Reset progress\r\n        context.scene.viewport_colors_progress = 0.0\r\n        \r\n        # Start a timer to process materials in batches\r\n        bpy.app.timers.register(self._process_batch)\r\n        \r\n        return {&#39;FINISHED&#39;}\r\n    \r\n    def _process_batch(self):\r\n        global material_results, current_material, processed_count, total_materials, is_processing, material_queue, current_index\r\n        \r\n        if not is_processing or len(material_queue) == 0:\r\n            is_processing = False\r\n            self.report_info()\r\n            return None\r\n        \r\n        # Get the batch size from scene properties\r\n        batch_size = bpy.context.scene.viewport_colors_batch_size\r\n        use_vectorized = bpy.context.scene.viewport_colors_use_vectorized\r\n        \r\n        # Process a batch of materials\r\n        batch_end = min(current_index + batch_size, len(material_queue))\r\n        batch = material_queue[current_index:batch_end]\r\n        \r\n        for material in batch:\r\n            # Skip if material is invalid or has been deleted\r\n            if material is None or material.name not in bpy.data.materials:\r\n                processed_count += 1\r\n                continue\r\n                \r\n            current_material = material.name\r\n            \r\n            # Process the material\r\n            color, status = process_material(material, use_vectorized)\r\n            \r\n            # Apply the color to the material\r\n            if color:\r\n                # Store the color change to apply later in main thread\r\n                material_results[material.name] = (color, status)\r\n                # Mark this material for color application\r\n                if not hasattr(self, &#39;pending_color_changes&#39;):\r\n                    self.pending_color_changes = []\r\n                self.pending_color_changes.append((material, color))\r\n            else:\r\n                # Store the result without color change\r\n                material_results[material.name] = (None, status)\r\n            \r\n            # Update processed count\r\n            processed_count += 1\r\n            \r\n            # Update progress\r\n            if total_materials &gt; 0:\r\n                bpy.context.scene.viewport_colors_progress = (processed_count / total_materials) * 100\r\n        \r\n        # Update the current index\r\n        current_index = batch_end\r\n        \r\n        # Force a redraw of the UI\r\n        for area in bpy.context.screen.areas:\r\n            area.tag_redraw()\r\n        \r\n        # Check if we&#39;re done\r\n        if current_index &gt;= len(material_queue):\r\n            is_processing = False\r\n            # Apply pending color changes in main thread\r\n            if hasattr(self, &#39;pending_color_changes&#39;) and self.pending_color_changes:\r\n                bpy.app.timers.register(self._apply_color_changes)\r\n            self.report_info()\r\n            return None\r\n        \r\n        # Continue processing\r\n        return 0.1  # Check again in 0.1 seconds\r\n    \r\n    def _apply_color_changes(self):\r\n        \&quot;\&quot;\&quot;Apply pending color changes in the main thread\&quot;\&quot;\&quot;\r\n        if not hasattr(self, &#39;pending_color_changes&#39;) or not self.pending_color_changes:\r\n            return None\r\n        \r\n        # Apply a batch of color changes\r\n        batch_size = 10  # Process 10 materials at a time\r\n        batch = self.pending_color_changes[:batch_size]\r\n        \r\n        for material, color in batch:\r\n            try:\r\n                if material and material.name in bpy.data.materials:\r\n                    material.diffuse_color = (*color, 1.0)\r\n            except Exception as e:\r\n                print(f\&quot;Could not set diffuse_color for {material.name if material else &#39;Unknown&#39;}: {e}\&quot;)\r\n        \r\n        # Remove processed items\r\n        self.pending_color_changes = self.pending_color_changes[batch_size:]\r\n        \r\n        # Continue if there are more to process\r\n        if self.pending_color_changes:\r\n            return 0.01  # Process next batch in 0.01 seconds\r\n        \r\n        # All done\r\n        print(f\&quot;Applied viewport colors to {len(batch)} materials\&quot;)\r\n        return None\r\n    \r\n    def report_info(self):\r\n        global processed_count, start_time\r\n        elapsed_time = time() - start_time\r\n        \r\n        # Count materials by status\r\n        preview_count = 0\r\n        node_count = 0\r\n        failed_count = 0\r\n        \r\n        for _, status in material_results.values():\r\n            if status == MaterialStatus.PREVIEW_BASED:\r\n                preview_count += 1\r\n            elif status == MaterialStatus.COMPLETED:\r\n                node_count += 1\r\n            elif status == MaterialStatus.FAILED:\r\n                failed_count += 1\r\n        \r\n        # Use a popup menu instead of self.report since this might be called from a timer\r\n        def draw_popup(self, context):\r\n            self.layout.label(text=f\&quot;Processed {processed_count} materials in {elapsed_time:.2f} seconds\&quot;)\r\n            self.layout.label(text=f\&quot;Thumbnail-based: {preview_count}, Node-based: {node_count}\&quot;)\r\n            self.layout.label(text=f\&quot;Failed: {failed_count}\&quot;)\r\n        \r\n        bpy.context.window_manager.popup_menu(draw_popup, title=\&quot;Processing Complete\&quot;, icon=&#39;INFO&#39;)\r\n\r\n\r\nclass VIEWPORT_OT_RefreshMaterialPreviews(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Regenerate material previews to avoid stale thumbnails\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.refresh_material_previews\&quot;\r\n    bl_label = \&quot;Refresh Material Previews\&quot;\r\n    bl_options = {&#39;REGISTER&#39;}\r\n\r\n    def execute(self, context):\r\n        try:\r\n            bpy.ops.wm.previews_clear()\r\n            bpy.ops.wm.previews_batch_generate()\r\n            bpy.ops.wm.previews_ensure()\r\n        except Exception as exc:\r\n            self.report({&#39;WARNING&#39;}, f\&quot;Preview refresh failed: {exc}\&quot;)\r\n            return {&#39;CANCELLED&#39;}\r\n\r\n        self.report({&#39;INFO&#39;}, \&quot;Material previews refreshed\&quot;)\r\n        return {&#39;FINISHED&#39;}\r\n\r\n\r\ndef correct_viewport_color(color):\r\n    \&quot;\&quot;\&quot;Adjust viewport colors by color intensity and saturation\&quot;\&quot;\&quot;\r\n    r, g, b = color\r\n    \r\n    # Get the color adjustment amount (-1 to +1) and scale it to ±10%\r\n    color_adjustment = bpy.context.scene.viewport_colors_darken_amount * 0.1\r\n    \r\n    # Get the saturation adjustment amount (-1 to +1) and scale it to ±10%\r\n    saturation_adjustment = bpy.context.scene.viewport_colors_value_amount * 0.1\r\n    \r\n    # First apply the color adjustment (RGB)\r\n    r = r + color_adjustment\r\n    g = g + color_adjustment\r\n    b = b + color_adjustment\r\n    \r\n    # Clamp RGB values after color adjustment\r\n    r = max(0.0, min(1.0, r))\r\n    g = max(0.0, min(1.0, g))\r\n    b = max(0.0, min(1.0, b))\r\n    \r\n    # Then apply the saturation adjustment using HSV\r\n    if saturation_adjustment != 0:\r\n        # Convert to HSV\r\n        h, s, v = colorsys.rgb_to_hsv(r, g, b)\r\n        \r\n        # Adjust saturation while preserving hue and value\r\n        s = s + saturation_adjustment\r\n        s = max(0.0, min(1.0, s))\r\n        \r\n        # Convert back to RGB\r\n        r, g, b = colorsys.hsv_to_rgb(h, s, v)\r\n    \r\n    return (r, g, b)\r\n\r\ndef process_material(material, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Process a material to determine its viewport color\&quot;\&quot;\&quot;\r\n    if not material:\r\n        print(f\&quot;Material is None, using fallback color\&quot;)\r\n        return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n    \r\n    if material.is_grease_pencil:\r\n        print(f\&quot;Material {material.name}: is a grease pencil material, using fallback color\&quot;)\r\n        return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n    \r\n    try:\r\n        # Get color from material thumbnail\r\n        print(f\&quot;Material {material.name}: Attempting to extract color from thumbnail\&quot;)\r\n        \r\n        # Get color from the material thumbnail\r\n        color = get_color_from_preview(material, use_vectorized)\r\n        \r\n        if color:\r\n            print(f\&quot;Material {material.name}: Thumbnail color = {color}\&quot;)\r\n            \r\n            # Correct color for viewport display\r\n            corrected_color = correct_viewport_color(color)\r\n            print(f\&quot;Material {material.name}: Corrected thumbnail color = {corrected_color}\&quot;)\r\n            \r\n            return corrected_color, MaterialStatus.PREVIEW_BASED\r\n        else:\r\n            print(f\&quot;Material {material.name}: Could not extract color from thumbnail, using fallback color\&quot;)\r\n            return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n        \r\n    except Exception as e:\r\n        print(f\&quot;Error processing material {material.name}: {e}\&quot;)\r\n        return (1, 1, 1), MaterialStatus.FAILED\r\n\r\ndef get_average_color(image, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Calculate the average color of an image\&quot;\&quot;\&quot;\r\n    if not image or not image.has_data:\r\n        return None\r\n    \r\n    # Get image pixels\r\n    pixels = list(image.pixels)\r\n    \r\n    if use_vectorized and np is not None:\r\n        # Use NumPy for faster processing\r\n        pixels_np = np.array(pixels)\r\n        \r\n        # Reshape to RGBA format\r\n        pixels_np = pixels_np.reshape(-1, 4)\r\n        \r\n        # Calculate average color (ignoring alpha)\r\n        avg_color = pixels_np[:, :3].mean(axis=0)\r\n        \r\n        return avg_color.tolist()\r\n    else:\r\n        # Fallback to pure Python\r\n        total_r, total_g, total_b = 0, 0, 0\r\n        pixel_count = len(pixels) // 4\r\n        \r\n        for i in range(0, len(pixels), 4):\r\n            total_r += pixels[i]\r\n            total_g += pixels[i+1]\r\n            total_b += pixels[i+2]\r\n        \r\n        if pixel_count &gt; 0:\r\n            return [total_r / pixel_count, total_g / pixel_count, total_b / pixel_count]\r\n        else:\r\n            return None\r\n\r\ndef find_image_node(node, visited=None):\r\n    \&quot;\&quot;\&quot;Find the first image node connected to the given node\&quot;\&quot;\&quot;\r\n    if visited is None:\r\n        visited = set()\r\n    \r\n    if node in visited:\r\n        return None\r\n    \r\n    visited.add(node)\r\n    \r\n    # Check if this is an image node\r\n    if node.type == &#39;TEX_IMAGE&#39; and node.image:\r\n        return node\r\n    \r\n    # Check input connections\r\n    for input_socket in node.inputs:\r\n        for link in input_socket.links:\r\n            from_node = link.from_node\r\n            result = find_image_node(from_node, visited)\r\n            if result:\r\n                return result\r\n    \r\n    return None\r\n\r\ndef find_color_source(node, socket_name=None, visited=None):\r\n    \&quot;\&quot;\&quot;\r\n    Recursively trace color data through nodes to find the source\r\n    This is an enhanced version that handles mix nodes and node groups\r\n    \&quot;\&quot;\&quot;\r\n    if visited is None:\r\n        visited = set()\r\n    \r\n    # Avoid infinite recursion\r\n    node_id = (node, socket_name)\r\n    if node_id in visited:\r\n        return None, None\r\n    \r\n    visited.add(node_id)\r\n    \r\n    # Handle different node types\r\n    if node.type == &#39;TEX_IMAGE&#39; and node.image:\r\n        # Direct image texture\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;RGB&#39;:\r\n        # Direct RGB color\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;VALTORGB&#39;:  # Color Ramp\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;MIX_RGB&#39; or node.type == &#39;MIX&#39;:\r\n        # For mix nodes, check the factor to determine which input to prioritize\r\n        factor = 0.5  # Default to equal mix\r\n        \r\n        # Try to get the factor value\r\n        if len(node.inputs) &gt;= 1:\r\n            if hasattr(node.inputs[0], &#39;default_value&#39;):\r\n                factor = node.inputs[0].default_value\r\n        \r\n        # If factor is close to 0, prioritize the first color input\r\n        # If factor is close to 1, prioritize the second color input\r\n        # Otherwise, check both with second having slightly higher priority\r\n        \r\n        if factor &lt; 0.1:  # Strongly favor first input\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n            # Fallback to second input\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n        elif factor &gt; 0.9:  # Strongly favor second input\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n            # Fallback to first input\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n        else:\r\n            # Check both inputs with slight preference for the second input (usually the main color)\r\n            # First try Color2 (second input)\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n            \r\n            # Then try Color1 (first input)\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n    \r\n    elif node.type == &#39;GROUP&#39;:\r\n        # Handle node groups by finding the group output node and tracing back\r\n        if node.node_tree:\r\n            # Find output node in the group\r\n            for group_node in node.node_tree.nodes:\r\n                if group_node.type == &#39;GROUP_OUTPUT&#39;:\r\n                    # Find which input socket corresponds to the color output\r\n                    for i, output in enumerate(node.outputs):\r\n                        if output.links and (socket_name is None or output.name == socket_name):\r\n                            # Find the corresponding input in the group output node\r\n                            if i &lt; len(group_node.inputs) and group_node.inputs[i].links:\r\n                                input_link = group_node.inputs[i].links[0]\r\n                                source_node = input_link.from_node\r\n                                source_socket = input_link.from_socket.name\r\n                                return find_color_source(source_node, source_socket, visited)\r\n    \r\n    elif node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n        # If we somehow got to a principled BSDF node, check its base color input\r\n        base_color_input = node.inputs.get(&#39;Base Color&#39;)\r\n        if base_color_input and base_color_input.links:\r\n            connected_node = base_color_input.links[0].from_node\r\n            return find_color_source(connected_node, None, visited)\r\n    \r\n    # For shader nodes, try to find color inputs\r\n    elif &#39;BSDF&#39; in node.type or &#39;SHADER&#39; in node.type:\r\n        # Look for color inputs in shader nodes\r\n        color_input_names = [&#39;Color&#39;, &#39;Base Color&#39;, &#39;Diffuse Color&#39;, &#39;Tint&#39;]\r\n        for name in color_input_names:\r\n            input_socket = node.inputs.get(name)\r\n            if input_socket and input_socket.links:\r\n                connected_node = input_socket.links[0].from_node\r\n                result_node, result_socket = find_color_source(connected_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n    \r\n    # For other node types, check all inputs\r\n    for input_socket in node.inputs:\r\n        if input_socket.links:\r\n            from_node = input_socket.links[0].from_node\r\n            result_node, result_socket = find_color_source(from_node, None, visited)\r\n            if result_node:\r\n                return result_node, result_socket\r\n    \r\n    # If we get here, no color source was found\r\n    return None, None\r\n\r\ndef get_final_color(material):\r\n    \&quot;\&quot;\&quot;Get the final color for a material\&quot;\&quot;\&quot;\r\n    if not material or not material.use_nodes:\r\n        print(f\&quot;Material {material.name if material else &#39;None&#39;} has no nodes\&quot;)\r\n        return None\r\n    \r\n    # Find the Principled BSDF node\r\n    principled_node = None\r\n    for node in material.node_tree.nodes:\r\n        if node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n            principled_node = node\r\n            break\r\n    \r\n    if not principled_node:\r\n        print(f\&quot;Material {material.name}: No Principled BSDF node found\&quot;)\r\n        return None\r\n    \r\n    # Get the Base Color input\r\n    base_color_input = principled_node.inputs.get(&#39;Base Color&#39;)\r\n    if not base_color_input:\r\n        print(f\&quot;Material {material.name}: No Base Color input found\&quot;)\r\n        return None\r\n    \r\n    # Check if there&#39;s a texture connected to the Base Color input\r\n    if base_color_input.links:\r\n        connected_node = base_color_input.links[0].from_node\r\n        print(f\&quot;Material {material.name}: Base Color connected to {connected_node.name} of type {connected_node.type}\&quot;)\r\n        \r\n        # Use the enhanced color source finding function\r\n        source_node, source_socket = find_color_source(connected_node)\r\n        \r\n        if source_node:\r\n            print(f\&quot;Material {material.name}: Found color source node {source_node.name} of type {source_node.type}\&quot;)\r\n            \r\n            # Handle different source node types\r\n            if source_node.type == &#39;TEX_IMAGE&#39; and source_node.image:\r\n                print(f\&quot;Material {material.name}: Using image texture {source_node.image.name}\&quot;)\r\n                color = get_average_color(source_node.image)\r\n                if color:\r\n                    print(f\&quot;Material {material.name}: Image average color = {color}\&quot;)\r\n                    return color\r\n                else:\r\n                    print(f\&quot;Material {material.name}: Could not calculate image average color\&quot;)\r\n            \r\n            # If it&#39;s a color ramp, get the average color from the ramp\r\n            elif source_node.type == &#39;VALTORGB&#39;:  # Color Ramp node\r\n                print(f\&quot;Material {material.name}: Using color ramp\&quot;)\r\n                # Get the average of the color stops\r\n                elements = source_node.color_ramp.elements\r\n                if elements:\r\n                    avg_color = [0, 0, 0]\r\n                    for element in elements:\r\n                        color = element.color[:3]  # Ignore alpha\r\n                        avg_color[0] += color[0]\r\n                        avg_color[1] += color[1]\r\n                        avg_color[2] += color[2]\r\n                    \r\n                    avg_color[0] /= len(elements)\r\n                    avg_color[1] /= len(elements)\r\n                    avg_color[2] /= len(elements)\r\n                    \r\n                    print(f\&quot;Material {material.name}: Color ramp average = {avg_color}\&quot;)\r\n                    return avg_color\r\n            \r\n            # If it&#39;s an RGB node, use its color\r\n            elif source_node.type == &#39;RGB&#39;:\r\n                color = list(source_node.outputs[0].default_value)[:3]\r\n                print(f\&quot;Material {material.name}: RGB node color = {color}\&quot;)\r\n                return color\r\n            \r\n            # For other node types, try to get color from the output socket\r\n            elif source_socket and hasattr(source_node.outputs, &#39;__getitem__&#39;):\r\n                for output in source_node.outputs:\r\n                    if output.name == source_socket:\r\n                        if hasattr(output, &#39;default_value&#39;) and len(output.default_value) &gt;= 3:\r\n                            color = list(output.default_value)[:3]\r\n                            print(f\&quot;Material {material.name}: Node output socket color = {color}\&quot;)\r\n                            return color\r\n            \r\n            print(f\&quot;Material {material.name}: Could not extract color from source node {source_node.name} of type {source_node.type}\&quot;)\r\n        else:\r\n            print(f\&quot;Material {material.name}: Could not find color source node in the node tree\&quot;)\r\n            \r\n            # Debug: Print the node tree structure to help diagnose the issue\r\n            print(f\&quot;Material {material.name}: Node tree structure:\&quot;)\r\n            for node in material.node_tree.nodes:\r\n                print(f\&quot;  - Node: {node.name}, Type: {node.type}\&quot;)\r\n                for input_socket in node.inputs:\r\n                    if input_socket.links:\r\n                        print(f\&quot;    - Input: {input_socket.name} connected to {input_socket.links[0].from_node.name}\&quot;)\r\n    \r\n    # If no texture or couldn&#39;t get texture color, use the base color value\r\n    color = list(base_color_input.default_value)[:3]\r\n    print(f\&quot;Material {material.name}: Using base color value = {color}\&quot;)\r\n    return color\r\n\r\ndef find_diffuse_texture(material):\r\n    \&quot;\&quot;\&quot;Find the diffuse texture in a material\&quot;\&quot;\&quot;\r\n    if not material or not material.use_nodes:\r\n        return None\r\n    \r\n    # Find the principled BSDF node\r\n    principled_node = None\r\n    for node in material.node_tree.nodes:\r\n        if node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n            principled_node = node\r\n            break\r\n    \r\n    if not principled_node:\r\n        return None\r\n    \r\n    # Find the base color input\r\n    base_color_input = principled_node.inputs.get(&#39;Base Color&#39;)\r\n    if not base_color_input or not base_color_input.links:\r\n        return None\r\n    \r\n    # Get the connected node\r\n    connected_node = base_color_input.links[0].from_node\r\n    \r\n    # Use the enhanced color source finding function\r\n    source_node, _ = find_color_source(connected_node)\r\n    \r\n    # Check if we found an image texture\r\n    if source_node and source_node.type == &#39;TEX_IMAGE&#39; and source_node.image:\r\n        return source_node.image\r\n    \r\n    return None\r\n\r\ndef get_status_icon(status):\r\n    \&quot;\&quot;\&quot;Get the icon for a material status\&quot;\&quot;\&quot;\r\n    if status == MaterialStatus.PENDING:\r\n        return &#39;TRIA_RIGHT&#39;\r\n    elif status == MaterialStatus.PROCESSING:\r\n        return &#39;SORTTIME&#39;\r\n    elif status == MaterialStatus.COMPLETED:\r\n        return &#39;CHECKMARK&#39;\r\n    elif status == MaterialStatus.PREVIEW_BASED:\r\n        return &#39;IMAGE_DATA&#39;\r\n    elif status == MaterialStatus.FAILED:\r\n        return &#39;ERROR&#39;\r\n    else:\r\n        return &#39;QUESTION&#39;\r\n\r\ndef get_status_text(status):\r\n    \&quot;\&quot;\&quot;Get the text for a material status\&quot;\&quot;\&quot;\r\n    if status == MaterialStatus.PENDING:\r\n        return \&quot;Pending\&quot;\r\n    elif status == MaterialStatus.PROCESSING:\r\n        return \&quot;Processing\&quot;\r\n    elif status == MaterialStatus.COMPLETED:\r\n        return \&quot;Node-based\&quot;\r\n    elif status == MaterialStatus.PREVIEW_BASED:\r\n        return \&quot;Thumbnail-based\&quot;\r\n    elif status == MaterialStatus.FAILED:\r\n        return \&quot;Failed\&quot;\r\n    else:\r\n        return \&quot;Unknown\&quot;\r\n\r\nclass VIEW3D_PT_BulkViewportDisplay(bpy.types.Panel):\r\n    \&quot;\&quot;\&quot;Bulk Viewport Display Panel\&quot;\&quot;\&quot;\r\n    bl_label = \&quot;Bulk Viewport Display\&quot;\r\n    bl_idname = \&quot;VIEW3D_PT_bulk_viewport_display\&quot;\r\n    bl_space_type = &#39;VIEW_3D&#39;\r\n    bl_region_type = &#39;UI&#39;\r\n    bl_category = &#39;Edit&#39;\r\n    bl_parent_id = \&quot;VIEW3D_PT_bulk_scene_tools\&quot;\r\n    bl_order = 3\r\n    \r\n    def draw(self, context):\r\n        layout = self.layout\r\n        \r\n        # Viewport Colors section\r\n        box = layout.box()\r\n        box.label(text=\&quot;Viewport Colors\&quot;)\r\n        \r\n        # Add description\r\n        col = box.column()\r\n        col.label(text=\&quot;Set viewport colors from material thumbnails\&quot;)\r\n        \r\n        # Add primary settings\r\n        col = box.column(align=True)\r\n        col.prop(context.scene, \&quot;viewport_colors_selected_only\&quot;)\r\n        col.operator(\&quot;bst.refresh_material_previews\&quot;, icon=&#39;FILE_REFRESH&#39;)\r\n        \r\n        # Add advanced options in a collapsible section\r\n        row = box.row()\r\n        row.prop(context.scene, \&quot;viewport_colors_show_advanced\&quot;, \r\n                 icon=&#39;DISCLOSURE_TRI_DOWN&#39; if context.scene.viewport_colors_show_advanced else &#39;DISCLOSURE_TRI_RIGHT&#39;,\r\n                 emboss=False)\r\n        row.label(text=\&quot;Advanced Options\&quot;)\r\n        \r\n        if context.scene.viewport_colors_show_advanced:\r\n            adv_col = box.column(align=True)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_batch_size\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_use_vectorized\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_darken_amount\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_value_amount\&quot;)\r\n        \r\n        # Add the operator button\r\n        row = box.row()\r\n        row.scale_y = 1.5\r\n        row.operator(\&quot;bst.set_viewport_colors\&quot;)\r\n        \r\n        # Show progress if processing\r\n        if is_processing:\r\n            row = box.row()\r\n            row.label(text=f\&quot;Processing: {processed_count}/{total_materials}\&quot;)\r\n            \r\n            # Add a progress bar\r\n            row = box.row()\r\n            row.prop(context.scene, \&quot;viewport_colors_progress\&quot;, text=\&quot;\&quot;)\r\n        \r\n        # Show material results if available\r\n        if material_results:\r\n            box.separator()\r\n            row = box.row()\r\n            row.prop(context.scene, \&quot;show_material_results\&quot;, \r\n                     icon=&#39;DISCLOSURE_TRI_DOWN&#39; if context.scene.show_material_results else &#39;DISCLOSURE_TRI_RIGHT&#39;,\r\n                     emboss=False)\r\n            row.label(text=\&quot;Material Results:\&quot;)\r\n            if context.scene.show_material_results:\r\n                # Create a scrollable list\r\n                material_box = box.box()\r\n                row = material_box.row()\r\n                col = row.column()\r\n                \r\n                # Collect materials to remove\r\n                materials_to_remove = []\r\n                \r\n                # Count materials by status\r\n                preview_count = 0\r\n                failed_count = 0\r\n                \r\n                # Display material results - use a copy of the keys to avoid modification during iteration\r\n                for material_name in list(material_results.keys()):\r\n                    color, status = material_results[material_name]\r\n                    \r\n                    # Update counts\r\n                    if status == MaterialStatus.PREVIEW_BASED:\r\n                        preview_count += 1\r\n                    elif status == MaterialStatus.FAILED:\r\n                        failed_count += 1\r\n                    \r\n                    row = col.row(align=True)\r\n                    \r\n                    # Add status icon\r\n                    row.label(text=\&quot;\&quot;, icon=get_status_icon(status))\r\n                    \r\n                    # Add material name with operator to select it\r\n                    op = row.operator(\&quot;bst.select_in_editor\&quot;, text=material_name)\r\n                    op.material_name = material_name\r\n                    \r\n                    # Add color preview\r\n                    if color:\r\n                        material = bpy.data.materials.get(material_name)\r\n                        if material:  # Check if material still exists\r\n                            row.prop(material, \&quot;diffuse_color\&quot;, text=\&quot;\&quot;)\r\n                        else:\r\n                            # Material no longer exists, show a placeholder color\r\n                            row.label(text=\&quot;\&quot;, icon=&#39;ERROR&#39;)\r\n                            # Mark for removal\r\n                            materials_to_remove.append(material_name)\r\n                \r\n                # Remove materials that no longer exist\r\n                for material_name in materials_to_remove:\r\n                    material_results.pop(material_name, None)\r\n                \r\n                # Show statistics\r\n                if len(material_results) &gt; 0:\r\n                    material_box.separator()\r\n                    stats_col = material_box.column(align=True)\r\n                    stats_col.label(text=f\&quot;Total: {len(material_results)} materials\&quot;)\r\n                    stats_col.label(text=f\&quot;Thumbnail-based: {preview_count}\&quot;)\r\n                    stats_col.label(text=f\&quot;Failed: {failed_count}\&quot;)\r\n\r\n        # Add the select diffuse nodes button at the bottom\r\n        layout.separator()\r\n        layout.operator(\&quot;bst.select_diffuse_nodes\&quot;, icon=&#39;NODE_TEXTURE&#39;)\r\n\r\nclass MATERIAL_OT_SelectInEditor(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Select this material in the editor\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.select_in_editor\&quot;\r\n    bl_label = \&quot;Select Material\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n    \r\n    material_name: bpy.props.StringProperty(  # type: ignore\r\n        name=\&quot;Material Name\&quot;,\r\n        description=\&quot;Name of the material to select\&quot;,\r\n        default=\&quot;\&quot;\r\n    )\r\n    \r\n    def execute(self, context):\r\n        # Find the material\r\n        material = bpy.data.materials.get(self.material_name)\r\n        if not material:\r\n            # Remove this entry from material_results to avoid future errors\r\n            if self.material_name in material_results:\r\n                material_results.pop(self.material_name, None)\r\n                # Force a redraw of the UI\r\n                for area in context.screen.areas:\r\n                    area.tag_redraw()\r\n            self.report({&#39;ERROR&#39;}, f\&quot;Material &#39;{self.material_name}&#39; not found\&quot;)\r\n            return {&#39;CANCELLED&#39;}\r\n        \r\n        # Find an object using this material\r\n        for obj in bpy.data.objects:\r\n            if obj.type == &#39;MESH&#39; and obj.data.materials:\r\n                for i, mat in enumerate(obj.data.materials):\r\n                    if mat == material:\r\n                        # Select the object\r\n                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)\r\n                        obj.select_set(True)\r\n                        context.view_layer.objects.active = obj\r\n                        \r\n                        # Set the active material index\r\n                        obj.active_material_index = i\r\n                        \r\n                        # Switch to material properties\r\n                        for area in context.screen.areas:\r\n                            if area.type == &#39;PROPERTIES&#39;:\r\n                                for space in area.spaces:\r\n                                    if space.type == &#39;PROPERTIES&#39;:\r\n                                        space.context = &#39;MATERIAL&#39;\r\n                        \r\n                        return {&#39;FINISHED&#39;}\r\n        \r\n        self.report({&#39;WARNING&#39;}, f\&quot;No object using material &#39;{self.material_name}&#39; found\&quot;)\r\n        return {&#39;CANCELLED&#39;}\r\n\r\ndef get_color_from_preview(material, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Extract the average color from a material thumbnail\&quot;\&quot;\&quot;\r\n    if not material:\r\n        return None\r\n    \r\n    # Force Blender to generate the material preview if it doesn&#39;t exist\r\n    # This uses Blender&#39;s internal preview generation system\r\n    preview = material.preview\r\n    if not preview:\r\n        return None\r\n    \r\n    # Ensure the preview is generated (this should be very fast as Blender maintains these)\r\n    if preview.icon_id == 0:\r\n        # Use Blender&#39;s standard preview size\r\n        preview.icon_size = (128, 128)\r\n        # This triggers Blender&#39;s internal preview generation\r\n        icon_id = preview.icon_id  # Store in variable instead of just accessing\r\n    \r\n    # Access the preview image data - these are the same thumbnails shown in the material panel\r\n    preview_image = preview.icon_pixels_float\r\n    \r\n    if not preview_image or len(preview_image) == 0:\r\n        return None\r\n    \r\n    if use_vectorized and np is not None:\r\n        # Use NumPy for faster processing\r\n        pixels_np = np.array(preview_image)\r\n        \r\n        # Reshape to RGBA format (preview is stored as a flat RGBA array)\r\n        pixels_np = pixels_np.reshape(-1, 4)\r\n        \r\n        # Calculate average color (ignoring alpha and any pure black pixels which are often the background)\r\n        # Filter out black pixels (background) by checking if R+G+B is very small\r\n        non_black_mask = np.sum(pixels_np[:, :3], axis=1) &gt; 0.05\r\n        \r\n        if np.any(non_black_mask):\r\n            # Only use non-black pixels for the average\r\n            avg_color = pixels_np[non_black_mask][:, :3].mean(axis=0)\r\n            return avg_color.tolist()\r\n        else:\r\n            # If all pixels are black, return the average of all pixels\r\n            avg_color = pixels_np[:, :3].mean(axis=0)\r\n            return avg_color.tolist()\r\n    else:\r\n        # Fallback to pure Python\r\n        total_r, total_g, total_b = 0, 0, 0\r\n        pixel_count = 0\r\n        non_black_count = 0\r\n        \r\n        # Process pixels in groups of 4 (RGBA)\r\n        for i in range(0, len(preview_image), 4):\r\n            r, g, b, a = preview_image[i:i+4]\r\n            \r\n            # Skip black pixels (background)\r\n            if r + g + b &gt; 0.05:\r\n                total_r += r\r\n                total_g += g\r\n                total_b += b\r\n                non_black_count += 1\r\n            \r\n            pixel_count += 1\r\n        \r\n        # If we found non-black pixels, use their average\r\n        if non_black_count &gt; 0:\r\n            return [total_r / non_black_count, total_g / non_black_count, total_b / non_black_count]\r\n        # Otherwise, use the average of all pixels\r\n        elif pixel_count &gt; 0:\r\n            return [total_r / pixel_count, total_g / pixel_count, total_b / pixel_count]\r\n        else:\r\n            return None\r\n\r\nclass VIEWPORT_OT_SelectDiffuseNodes(bpy.types.Operator):\r\n    bl_idname = \&quot;bst.select_diffuse_nodes\&quot;\r\n    bl_label = \&quot;Set Texture Display\&quot;\r\n    bl_description = \&quot;Select the most relevant diffuse/base color image texture node in each material\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n\r\n    def execute(self, context):\r\n        if select_diffuse_nodes:\r\n            select_diffuse_nodes()\r\n            self.report({&#39;INFO&#39;}, \&quot;Diffuse/BaseColor image nodes selected.\&quot;)\r\n        else:\r\n            self.report({&#39;ERROR&#39;}, \&quot;select_diffuse_nodes function not found.\&quot;)\r\n        return {&#39;FINISHED&#39;}\r\n\r\n# List of all classes in this module\r\nclasses = (\r\n    VIEWPORT_OT_SetViewportColors,\r\n    VIEW3D_PT_BulkViewportDisplay,\r\n    MATERIAL_OT_SelectInEditor,\r\n    VIEWPORT_OT_SelectDiffuseNodes,\r\n)\r\n\r\n# Registration\r\ndef register():\r\n    for cls in classes:\r\n        bpy.utils.register_class(cls)\r\n    \r\n    # Register properties\r\n    register_viewport_properties()\r\n\r\ndef unregister():\r\n    # Unregister properties\r\n    try:\r\n        unregister_viewport_properties()\r\n    except Exception:\r\n        pass\r\n    # Unregister classes\r\n    for cls in reversed(classes):\r\n        try:\r\n            bpy.utils.unregister_class(cls)\r\n        except RuntimeError:\r\n            pass &quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking tuple class usage**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: panels/bulk_viewport_display.py</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Requesting more tuple data**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: panels/bulk_viewport_display.py</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Adding new operator and updating UI**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;panels/bulk_viewport_display.py&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;fc5df35a-de40-4efd-90f4-ff90ac798166&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  classes = (\r\n      VIEWPORT_OT_SetViewportColors,\r\n+     VIEWPORT_OT_RefreshMaterialPreviews,\r\n      VIEW3D_PT_BulkViewportDisplay,\r\n      MATERIAL_OT_SelectInEditor,\r&quot;,
        &quot;oldStart&quot;: 958,
        &quot;newStart&quot;: 958,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 5,
        &quot;linesAdded&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM panels/bulk_viewport_display.py&quot;,
  &quot;contentsAfterEdit&quot;: &quot;import bpy # type: ignore\r\nimport numpy as np\r\nfrom time import time\r\nimport os\r\nfrom enum import Enum\r\nimport colorsys  # Add colorsys for RGB to HSV conversion\r\nfrom ..ops.select_diffuse_nodes import select_diffuse_nodes  # Import the specific function\r\n\r\n# Material processing status enum\r\nclass MaterialStatus(Enum):\r\n    PENDING = 0\r\n    PROCESSING = 1\r\n    COMPLETED = 2\r\n    FAILED = 3\r\n    PREVIEW_BASED = 4\r\n\r\n# Global variables to store results and track progress\r\nmaterial_results = {}  # {material_name: (color, status)}\r\ncurrent_material = \&quot;\&quot;\r\nprocessed_count = 0\r\ntotal_materials = 0\r\nstart_time = 0\r\nis_processing = False\r\nmaterial_queue = []\r\ncurrent_index = 0\r\n\r\n# Scene properties for viewport display settings\r\ndef register_viewport_properties():\r\n    bpy.types.Scene.viewport_colors_selected_only = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Selected Objects Only\&quot;,\r\n        description=\&quot;Apply viewport colors only to materials in selected objects\&quot;,\r\n        default=False\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_batch_size = bpy.props.IntProperty(  # type: ignore\r\n        name=\&quot;Batch Size\&quot;,\r\n        description=\&quot;Number of materials to process in each batch\&quot;,\r\n        default=50,\r\n        min=1,\r\n        max=50\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_use_vectorized = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Use Vectorized Processing\&quot;,\r\n        description=\&quot;Use vectorized operations for image processing (faster but uses more memory)\&quot;,\r\n        default=True\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_darken_amount = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Color Adjustment\&quot;,\r\n        description=\&quot;Adjust viewport colors by ±10% (+1 = +10% lighter, 0 = no change, -1 = -10% darker)\&quot;,\r\n        default=0.0,\r\n        min=-1.0,\r\n        max=1.0,\r\n        subtype=&#39;FACTOR&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_value_amount = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Saturation Adjustment\&quot;,\r\n        description=\&quot;Adjust color saturation by ±10% (+1 = +10% more saturated, 0 = no change, -1 = -10% less saturated)\&quot;,\r\n        default=1.0,\r\n        min=-1.0,\r\n        max=1.0,\r\n        subtype=&#39;FACTOR&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_progress = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Progress\&quot;,\r\n        description=\&quot;Progress of the viewport color setting operation\&quot;,\r\n        default=0.0,\r\n        min=0.0,\r\n        max=100.0,\r\n        subtype=&#39;PERCENTAGE&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_show_advanced = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Show Advanced Options\&quot;,\r\n        description=\&quot;Show advanced options for viewport color extraction\&quot;,\r\n        default=False\r\n    )\r\n    \r\n    # New properties for thumbnail-based color extraction\r\n    bpy.types.Scene.viewport_colors_use_preview = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Use Material Thumbnails\&quot;,\r\n        description=\&quot;Use Blender&#39;s material thumbnails for color extraction (faster and more reliable)\&quot;,\r\n        default=True\r\n    )\r\n\r\n    bpy.types.Scene.show_material_results = bpy.props.BoolProperty(\r\n        name=\&quot;\&quot;,\r\n        description=\&quot;Show material results in the viewport display panel\&quot;,\r\n        default=True\r\n    )\r\n\r\ndef unregister_viewport_properties():\r\n    del bpy.types.Scene.viewport_colors_use_preview\r\n    del bpy.types.Scene.viewport_colors_batch_size\r\n    del bpy.types.Scene.viewport_colors_use_vectorized\r\n    del bpy.types.Scene.viewport_colors_darken_amount\r\n    del bpy.types.Scene.viewport_colors_value_amount\r\n    del bpy.types.Scene.viewport_colors_progress\r\n    del bpy.types.Scene.viewport_colors_selected_only\r\n    del bpy.types.Scene.viewport_colors_show_advanced\r\n    del bpy.types.Scene.show_material_results\r\n\r\nclass VIEWPORT_OT_SetViewportColors(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Set Viewport Display colors from BSDF base color or texture\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.set_viewport_colors\&quot;\r\n    bl_label = \&quot;Set Viewport Colors\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n    \r\n    def execute(self, context):\r\n        global material_results, current_material, processed_count, total_materials, start_time, is_processing, material_queue, current_index\r\n        \r\n        # Reset global variables\r\n        material_results = {}\r\n        current_material = \&quot;\&quot;\r\n        processed_count = 0\r\n        is_processing = True\r\n        start_time = time()\r\n        current_index = 0\r\n        \r\n        # Get materials based on selection mode\r\n        if context.scene.viewport_colors_selected_only:\r\n            # Get materials from selected objects only\r\n            materials = []\r\n            for obj in context.selected_objects:\r\n                if obj.type == &#39;MESH&#39; and obj.data.materials:\r\n                    for mat in obj.data.materials:\r\n                        if mat and not mat.is_grease_pencil and mat not in materials:\r\n                            materials.append(mat)\r\n        else:\r\n            # Get all materials in the scene\r\n            materials = [mat for mat in bpy.data.materials if not mat.is_grease_pencil]\r\n        \r\n        total_materials = len(materials)\r\n        material_queue = materials.copy()\r\n        \r\n        if total_materials == 0:\r\n            self.report({&#39;WARNING&#39;}, \&quot;No materials found to process\&quot;)\r\n            is_processing = False\r\n            return {&#39;CANCELLED&#39;}\r\n        \r\n        # Reset progress\r\n        context.scene.viewport_colors_progress = 0.0\r\n        \r\n        # Start a timer to process materials in batches\r\n        bpy.app.timers.register(self._process_batch)\r\n        \r\n        return {&#39;FINISHED&#39;}\r\n    \r\n    def _process_batch(self):\r\n        global material_results, current_material, processed_count, total_materials, is_processing, material_queue, current_index\r\n        \r\n        if not is_processing or len(material_queue) == 0:\r\n            is_processing = False\r\n            self.report_info()\r\n            return None\r\n        \r\n        # Get the batch size from scene properties\r\n        batch_size = bpy.context.scene.viewport_colors_batch_size\r\n        use_vectorized = bpy.context.scene.viewport_colors_use_vectorized\r\n        \r\n        # Process a batch of materials\r\n        batch_end = min(current_index + batch_size, len(material_queue))\r\n        batch = material_queue[current_index:batch_end]\r\n        \r\n        for material in batch:\r\n            # Skip if material is invalid or has been deleted\r\n            if material is None or material.name not in bpy.data.materials:\r\n                processed_count += 1\r\n                continue\r\n                \r\n            current_material = material.name\r\n            \r\n            # Process the material\r\n            color, status = process_material(material, use_vectorized)\r\n            \r\n            # Apply the color to the material\r\n            if color:\r\n                # Store the color change to apply later in main thread\r\n                material_results[material.name] = (color, status)\r\n                # Mark this material for color application\r\n                if not hasattr(self, &#39;pending_color_changes&#39;):\r\n                    self.pending_color_changes = []\r\n                self.pending_color_changes.append((material, color))\r\n            else:\r\n                # Store the result without color change\r\n                material_results[material.name] = (None, status)\r\n            \r\n            # Update processed count\r\n            processed_count += 1\r\n            \r\n            # Update progress\r\n            if total_materials &gt; 0:\r\n                bpy.context.scene.viewport_colors_progress = (processed_count / total_materials) * 100\r\n        \r\n        # Update the current index\r\n        current_index = batch_end\r\n        \r\n        # Force a redraw of the UI\r\n        for area in bpy.context.screen.areas:\r\n            area.tag_redraw()\r\n        \r\n        # Check if we&#39;re done\r\n        if current_index &gt;= len(material_queue):\r\n            is_processing = False\r\n            # Apply pending color changes in main thread\r\n            if hasattr(self, &#39;pending_color_changes&#39;) and self.pending_color_changes:\r\n                bpy.app.timers.register(self._apply_color_changes)\r\n            self.report_info()\r\n            return None\r\n        \r\n        # Continue processing\r\n        return 0.1  # Check again in 0.1 seconds\r\n    \r\n    def _apply_color_changes(self):\r\n        \&quot;\&quot;\&quot;Apply pending color changes in the main thread\&quot;\&quot;\&quot;\r\n        if not hasattr(self, &#39;pending_color_changes&#39;) or not self.pending_color_changes:\r\n            return None\r\n        \r\n        # Apply a batch of color changes\r\n        batch_size = 10  # Process 10 materials at a time\r\n        batch = self.pending_color_changes[:batch_size]\r\n        \r\n        for material, color in batch:\r\n            try:\r\n                if material and material.name in bpy.data.materials:\r\n                    material.diffuse_color = (*color, 1.0)\r\n            except Exception as e:\r\n                print(f\&quot;Could not set diffuse_color for {material.name if material else &#39;Unknown&#39;}: {e}\&quot;)\r\n        \r\n        # Remove processed items\r\n        self.pending_color_changes = self.pending_color_changes[batch_size:]\r\n        \r\n        # Continue if there are more to process\r\n        if self.pending_color_changes:\r\n            return 0.01  # Process next batch in 0.01 seconds\r\n        \r\n        # All done\r\n        print(f\&quot;Applied viewport colors to {len(batch)} materials\&quot;)\r\n        return None\r\n    \r\n    def report_info(self):\r\n        global processed_count, start_time\r\n        elapsed_time = time() - start_time\r\n        \r\n        # Count materials by status\r\n        preview_count = 0\r\n        node_count = 0\r\n        failed_count = 0\r\n        \r\n        for _, status in material_results.values():\r\n            if status == MaterialStatus.PREVIEW_BASED:\r\n                preview_count += 1\r\n            elif status == MaterialStatus.COMPLETED:\r\n                node_count += 1\r\n            elif status == MaterialStatus.FAILED:\r\n                failed_count += 1\r\n        \r\n        # Use a popup menu instead of self.report since this might be called from a timer\r\n        def draw_popup(self, context):\r\n            self.layout.label(text=f\&quot;Processed {processed_count} materials in {elapsed_time:.2f} seconds\&quot;)\r\n            self.layout.label(text=f\&quot;Thumbnail-based: {preview_count}, Node-based: {node_count}\&quot;)\r\n            self.layout.label(text=f\&quot;Failed: {failed_count}\&quot;)\r\n        \r\n        bpy.context.window_manager.popup_menu(draw_popup, title=\&quot;Processing Complete\&quot;, icon=&#39;INFO&#39;)\r\n\r\n\r\nclass VIEWPORT_OT_RefreshMaterialPreviews(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Regenerate material previews to avoid stale thumbnails\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.refresh_material_previews\&quot;\r\n    bl_label = \&quot;Refresh Material Previews\&quot;\r\n    bl_options = {&#39;REGISTER&#39;}\r\n\r\n    def execute(self, context):\r\n        try:\r\n            bpy.ops.wm.previews_clear()\r\n            bpy.ops.wm.previews_batch_generate()\r\n            bpy.ops.wm.previews_ensure()\r\n        except Exception as exc:\r\n            self.report({&#39;WARNING&#39;}, f\&quot;Preview refresh failed: {exc}\&quot;)\r\n            return {&#39;CANCELLED&#39;}\r\n\r\n        self.report({&#39;INFO&#39;}, \&quot;Material previews refreshed\&quot;)\r\n        return {&#39;FINISHED&#39;}\r\n\r\n\r\ndef correct_viewport_color(color):\r\n    \&quot;\&quot;\&quot;Adjust viewport colors by color intensity and saturation\&quot;\&quot;\&quot;\r\n    r, g, b = color\r\n    \r\n    # Get the color adjustment amount (-1 to +1) and scale it to ±10%\r\n    color_adjustment = bpy.context.scene.viewport_colors_darken_amount * 0.1\r\n    \r\n    # Get the saturation adjustment amount (-1 to +1) and scale it to ±10%\r\n    saturation_adjustment = bpy.context.scene.viewport_colors_value_amount * 0.1\r\n    \r\n    # First apply the color adjustment (RGB)\r\n    r = r + color_adjustment\r\n    g = g + color_adjustment\r\n    b = b + color_adjustment\r\n    \r\n    # Clamp RGB values after color adjustment\r\n    r = max(0.0, min(1.0, r))\r\n    g = max(0.0, min(1.0, g))\r\n    b = max(0.0, min(1.0, b))\r\n    \r\n    # Then apply the saturation adjustment using HSV\r\n    if saturation_adjustment != 0:\r\n        # Convert to HSV\r\n        h, s, v = colorsys.rgb_to_hsv(r, g, b)\r\n        \r\n        # Adjust saturation while preserving hue and value\r\n        s = s + saturation_adjustment\r\n        s = max(0.0, min(1.0, s))\r\n        \r\n        # Convert back to RGB\r\n        r, g, b = colorsys.hsv_to_rgb(h, s, v)\r\n    \r\n    return (r, g, b)\r\n\r\ndef process_material(material, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Process a material to determine its viewport color\&quot;\&quot;\&quot;\r\n    if not material:\r\n        print(f\&quot;Material is None, using fallback color\&quot;)\r\n        return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n    \r\n    if material.is_grease_pencil:\r\n        print(f\&quot;Material {material.name}: is a grease pencil material, using fallback color\&quot;)\r\n        return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n    \r\n    try:\r\n        # Get color from material thumbnail\r\n        print(f\&quot;Material {material.name}: Attempting to extract color from thumbnail\&quot;)\r\n        \r\n        # Get color from the material thumbnail\r\n        color = get_color_from_preview(material, use_vectorized)\r\n        \r\n        if color:\r\n            print(f\&quot;Material {material.name}: Thumbnail color = {color}\&quot;)\r\n            \r\n            # Correct color for viewport display\r\n            corrected_color = correct_viewport_color(color)\r\n            print(f\&quot;Material {material.name}: Corrected thumbnail color = {corrected_color}\&quot;)\r\n            \r\n            return corrected_color, MaterialStatus.PREVIEW_BASED\r\n        else:\r\n            print(f\&quot;Material {material.name}: Could not extract color from thumbnail, using fallback color\&quot;)\r\n            return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n        \r\n    except Exception as e:\r\n        print(f\&quot;Error processing material {material.name}: {e}\&quot;)\r\n        return (1, 1, 1), MaterialStatus.FAILED\r\n\r\ndef get_average_color(image, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Calculate the average color of an image\&quot;\&quot;\&quot;\r\n    if not image or not image.has_data:\r\n        return None\r\n    \r\n    # Get image pixels\r\n    pixels = list(image.pixels)\r\n    \r\n    if use_vectorized and np is not None:\r\n        # Use NumPy for faster processing\r\n        pixels_np = np.array(pixels)\r\n        \r\n        # Reshape to RGBA format\r\n        pixels_np = pixels_np.reshape(-1, 4)\r\n        \r\n        # Calculate average color (ignoring alpha)\r\n        avg_color = pixels_np[:, :3].mean(axis=0)\r\n        \r\n        return avg_color.tolist()\r\n    else:\r\n        # Fallback to pure Python\r\n        total_r, total_g, total_b = 0, 0, 0\r\n        pixel_count = len(pixels) // 4\r\n        \r\n        for i in range(0, len(pixels), 4):\r\n            total_r += pixels[i]\r\n            total_g += pixels[i+1]\r\n            total_b += pixels[i+2]\r\n        \r\n        if pixel_count &gt; 0:\r\n            return [total_r / pixel_count, total_g / pixel_count, total_b / pixel_count]\r\n        else:\r\n            return None\r\n\r\ndef find_image_node(node, visited=None):\r\n    \&quot;\&quot;\&quot;Find the first image node connected to the given node\&quot;\&quot;\&quot;\r\n    if visited is None:\r\n        visited = set()\r\n    \r\n    if node in visited:\r\n        return None\r\n    \r\n    visited.add(node)\r\n    \r\n    # Check if this is an image node\r\n    if node.type == &#39;TEX_IMAGE&#39; and node.image:\r\n        return node\r\n    \r\n    # Check input connections\r\n    for input_socket in node.inputs:\r\n        for link in input_socket.links:\r\n            from_node = link.from_node\r\n            result = find_image_node(from_node, visited)\r\n            if result:\r\n                return result\r\n    \r\n    return None\r\n\r\ndef find_color_source(node, socket_name=None, visited=None):\r\n    \&quot;\&quot;\&quot;\r\n    Recursively trace color data through nodes to find the source\r\n    This is an enhanced version that handles mix nodes and node groups\r\n    \&quot;\&quot;\&quot;\r\n    if visited is None:\r\n        visited = set()\r\n    \r\n    # Avoid infinite recursion\r\n    node_id = (node, socket_name)\r\n    if node_id in visited:\r\n        return None, None\r\n    \r\n    visited.add(node_id)\r\n    \r\n    # Handle different node types\r\n    if node.type == &#39;TEX_IMAGE&#39; and node.image:\r\n        # Direct image texture\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;RGB&#39;:\r\n        # Direct RGB color\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;VALTORGB&#39;:  # Color Ramp\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;MIX_RGB&#39; or node.type == &#39;MIX&#39;:\r\n        # For mix nodes, check the factor to determine which input to prioritize\r\n        factor = 0.5  # Default to equal mix\r\n        \r\n        # Try to get the factor value\r\n        if len(node.inputs) &gt;= 1:\r\n            if hasattr(node.inputs[0], &#39;default_value&#39;):\r\n                factor = node.inputs[0].default_value\r\n        \r\n        # If factor is close to 0, prioritize the first color input\r\n        # If factor is close to 1, prioritize the second color input\r\n        # Otherwise, check both with second having slightly higher priority\r\n        \r\n        if factor &lt; 0.1:  # Strongly favor first input\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n            # Fallback to second input\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n        elif factor &gt; 0.9:  # Strongly favor second input\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n            # Fallback to first input\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n        else:\r\n            # Check both inputs with slight preference for the second input (usually the main color)\r\n            # First try Color2 (second input)\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n            \r\n            # Then try Color1 (first input)\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n    \r\n    elif node.type == &#39;GROUP&#39;:\r\n        # Handle node groups by finding the group output node and tracing back\r\n        if node.node_tree:\r\n            # Find output node in the group\r\n            for group_node in node.node_tree.nodes:\r\n                if group_node.type == &#39;GROUP_OUTPUT&#39;:\r\n                    # Find which input socket corresponds to the color output\r\n                    for i, output in enumerate(node.outputs):\r\n                        if output.links and (socket_name is None or output.name == socket_name):\r\n                            # Find the corresponding input in the group output node\r\n                            if i &lt; len(group_node.inputs) and group_node.inputs[i].links:\r\n                                input_link = group_node.inputs[i].links[0]\r\n                                source_node = input_link.from_node\r\n                                source_socket = input_link.from_socket.name\r\n                                return find_color_source(source_node, source_socket, visited)\r\n    \r\n    elif node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n        # If we somehow got to a principled BSDF node, check its base color input\r\n        base_color_input = node.inputs.get(&#39;Base Color&#39;)\r\n        if base_color_input and base_color_input.links:\r\n            connected_node = base_color_input.links[0].from_node\r\n            return find_color_source(connected_node, None, visited)\r\n    \r\n    # For shader nodes, try to find color inputs\r\n    elif &#39;BSDF&#39; in node.type or &#39;SHADER&#39; in node.type:\r\n        # Look for color inputs in shader nodes\r\n        color_input_names = [&#39;Color&#39;, &#39;Base Color&#39;, &#39;Diffuse Color&#39;, &#39;Tint&#39;]\r\n        for name in color_input_names:\r\n            input_socket = node.inputs.get(name)\r\n            if input_socket and input_socket.links:\r\n                connected_node = input_socket.links[0].from_node\r\n                result_node, result_socket = find_color_source(connected_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n    \r\n    # For other node types, check all inputs\r\n    for input_socket in node.inputs:\r\n        if input_socket.links:\r\n            from_node = input_socket.links[0].from_node\r\n            result_node, result_socket = find_color_source(from_node, None, visited)\r\n            if result_node:\r\n                return result_node, result_socket\r\n    \r\n    # If we get here, no color source was found\r\n    return None, None\r\n\r\ndef get_final_color(material):\r\n    \&quot;\&quot;\&quot;Get the final color for a material\&quot;\&quot;\&quot;\r\n    if not material or not material.use_nodes:\r\n        print(f\&quot;Material {material.name if material else &#39;None&#39;} has no nodes\&quot;)\r\n        return None\r\n    \r\n    # Find the Principled BSDF node\r\n    principled_node = None\r\n    for node in material.node_tree.nodes:\r\n        if node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n            principled_node = node\r\n            break\r\n    \r\n    if not principled_node:\r\n        print(f\&quot;Material {material.name}: No Principled BSDF node found\&quot;)\r\n        return None\r\n    \r\n    # Get the Base Color input\r\n    base_color_input = principled_node.inputs.get(&#39;Base Color&#39;)\r\n    if not base_color_input:\r\n        print(f\&quot;Material {material.name}: No Base Color input found\&quot;)\r\n        return None\r\n    \r\n    # Check if there&#39;s a texture connected to the Base Color input\r\n    if base_color_input.links:\r\n        connected_node = base_color_input.links[0].from_node\r\n        print(f\&quot;Material {material.name}: Base Color connected to {connected_node.name} of type {connected_node.type}\&quot;)\r\n        \r\n        # Use the enhanced color source finding function\r\n        source_node, source_socket = find_color_source(connected_node)\r\n        \r\n        if source_node:\r\n            print(f\&quot;Material {material.name}: Found color source node {source_node.name} of type {source_node.type}\&quot;)\r\n            \r\n            # Handle different source node types\r\n            if source_node.type == &#39;TEX_IMAGE&#39; and source_node.image:\r\n                print(f\&quot;Material {material.name}: Using image texture {source_node.image.name}\&quot;)\r\n                color = get_average_color(source_node.image)\r\n                if color:\r\n                    print(f\&quot;Material {material.name}: Image average color = {color}\&quot;)\r\n                    return color\r\n                else:\r\n                    print(f\&quot;Material {material.name}: Could not calculate image average color\&quot;)\r\n            \r\n            # If it&#39;s a color ramp, get the average color from the ramp\r\n            elif source_node.type == &#39;VALTORGB&#39;:  # Color Ramp node\r\n                print(f\&quot;Material {material.name}: Using color ramp\&quot;)\r\n                # Get the average of the color stops\r\n                elements = source_node.color_ramp.elements\r\n                if elements:\r\n                    avg_color = [0, 0, 0]\r\n                    for element in elements:\r\n                        color = element.color[:3]  # Ignore alpha\r\n                        avg_color[0] += color[0]\r\n                        avg_color[1] += color[1]\r\n                        avg_color[2] += color[2]\r\n                    \r\n                    avg_color[0] /= len(elements)\r\n                    avg_color[1] /= len(elements)\r\n                    avg_color[2] /= len(elements)\r\n                    \r\n                    print(f\&quot;Material {material.name}: Color ramp average = {avg_color}\&quot;)\r\n                    return avg_color\r\n            \r\n            # If it&#39;s an RGB node, use its color\r\n            elif source_node.type == &#39;RGB&#39;:\r\n                color = list(source_node.outputs[0].default_value)[:3]\r\n                print(f\&quot;Material {material.name}: RGB node color = {color}\&quot;)\r\n                return color\r\n            \r\n            # For other node types, try to get color from the output socket\r\n            elif source_socket and hasattr(source_node.outputs, &#39;__getitem__&#39;):\r\n                for output in source_node.outputs:\r\n                    if output.name == source_socket:\r\n                        if hasattr(output, &#39;default_value&#39;) and len(output.default_value) &gt;= 3:\r\n                            color = list(output.default_value)[:3]\r\n                            print(f\&quot;Material {material.name}: Node output socket color = {color}\&quot;)\r\n                            return color\r\n            \r\n            print(f\&quot;Material {material.name}: Could not extract color from source node {source_node.name} of type {source_node.type}\&quot;)\r\n        else:\r\n            print(f\&quot;Material {material.name}: Could not find color source node in the node tree\&quot;)\r\n            \r\n            # Debug: Print the node tree structure to help diagnose the issue\r\n            print(f\&quot;Material {material.name}: Node tree structure:\&quot;)\r\n            for node in material.node_tree.nodes:\r\n                print(f\&quot;  - Node: {node.name}, Type: {node.type}\&quot;)\r\n                for input_socket in node.inputs:\r\n                    if input_socket.links:\r\n                        print(f\&quot;    - Input: {input_socket.name} connected to {input_socket.links[0].from_node.name}\&quot;)\r\n    \r\n    # If no texture or couldn&#39;t get texture color, use the base color value\r\n    color = list(base_color_input.default_value)[:3]\r\n    print(f\&quot;Material {material.name}: Using base color value = {color}\&quot;)\r\n    return color\r\n\r\ndef find_diffuse_texture(material):\r\n    \&quot;\&quot;\&quot;Find the diffuse texture in a material\&quot;\&quot;\&quot;\r\n    if not material or not material.use_nodes:\r\n        return None\r\n    \r\n    # Find the principled BSDF node\r\n    principled_node = None\r\n    for node in material.node_tree.nodes:\r\n        if node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n            principled_node = node\r\n            break\r\n    \r\n    if not principled_node:\r\n        return None\r\n    \r\n    # Find the base color input\r\n    base_color_input = principled_node.inputs.get(&#39;Base Color&#39;)\r\n    if not base_color_input or not base_color_input.links:\r\n        return None\r\n    \r\n    # Get the connected node\r\n    connected_node = base_color_input.links[0].from_node\r\n    \r\n    # Use the enhanced color source finding function\r\n    source_node, _ = find_color_source(connected_node)\r\n    \r\n    # Check if we found an image texture\r\n    if source_node and source_node.type == &#39;TEX_IMAGE&#39; and source_node.image:\r\n        return source_node.image\r\n    \r\n    return None\r\n\r\ndef get_status_icon(status):\r\n    \&quot;\&quot;\&quot;Get the icon for a material status\&quot;\&quot;\&quot;\r\n    if status == MaterialStatus.PENDING:\r\n        return &#39;TRIA_RIGHT&#39;\r\n    elif status == MaterialStatus.PROCESSING:\r\n        return &#39;SORTTIME&#39;\r\n    elif status == MaterialStatus.COMPLETED:\r\n        return &#39;CHECKMARK&#39;\r\n    elif status == MaterialStatus.PREVIEW_BASED:\r\n        return &#39;IMAGE_DATA&#39;\r\n    elif status == MaterialStatus.FAILED:\r\n        return &#39;ERROR&#39;\r\n    else:\r\n        return &#39;QUESTION&#39;\r\n\r\ndef get_status_text(status):\r\n    \&quot;\&quot;\&quot;Get the text for a material status\&quot;\&quot;\&quot;\r\n    if status == MaterialStatus.PENDING:\r\n        return \&quot;Pending\&quot;\r\n    elif status == MaterialStatus.PROCESSING:\r\n        return \&quot;Processing\&quot;\r\n    elif status == MaterialStatus.COMPLETED:\r\n        return \&quot;Node-based\&quot;\r\n    elif status == MaterialStatus.PREVIEW_BASED:\r\n        return \&quot;Thumbnail-based\&quot;\r\n    elif status == MaterialStatus.FAILED:\r\n        return \&quot;Failed\&quot;\r\n    else:\r\n        return \&quot;Unknown\&quot;\r\n\r\nclass VIEW3D_PT_BulkViewportDisplay(bpy.types.Panel):\r\n    \&quot;\&quot;\&quot;Bulk Viewport Display Panel\&quot;\&quot;\&quot;\r\n    bl_label = \&quot;Bulk Viewport Display\&quot;\r\n    bl_idname = \&quot;VIEW3D_PT_bulk_viewport_display\&quot;\r\n    bl_space_type = &#39;VIEW_3D&#39;\r\n    bl_region_type = &#39;UI&#39;\r\n    bl_category = &#39;Edit&#39;\r\n    bl_parent_id = \&quot;VIEW3D_PT_bulk_scene_tools\&quot;\r\n    bl_order = 3\r\n    \r\n    def draw(self, context):\r\n        layout = self.layout\r\n        \r\n        # Viewport Colors section\r\n        box = layout.box()\r\n        box.label(text=\&quot;Viewport Colors\&quot;)\r\n        \r\n        # Add description\r\n        col = box.column()\r\n        col.label(text=\&quot;Set viewport colors from material thumbnails\&quot;)\r\n        \r\n        # Add primary settings\r\n        col = box.column(align=True)\r\n        col.prop(context.scene, \&quot;viewport_colors_selected_only\&quot;)\r\n        col.operator(\&quot;bst.refresh_material_previews\&quot;, icon=&#39;FILE_REFRESH&#39;)\r\n        \r\n        # Add advanced options in a collapsible section\r\n        row = box.row()\r\n        row.prop(context.scene, \&quot;viewport_colors_show_advanced\&quot;, \r\n                 icon=&#39;DISCLOSURE_TRI_DOWN&#39; if context.scene.viewport_colors_show_advanced else &#39;DISCLOSURE_TRI_RIGHT&#39;,\r\n                 emboss=False)\r\n        row.label(text=\&quot;Advanced Options\&quot;)\r\n        \r\n        if context.scene.viewport_colors_show_advanced:\r\n            adv_col = box.column(align=True)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_batch_size\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_use_vectorized\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_darken_amount\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_value_amount\&quot;)\r\n        \r\n        # Add the operator button\r\n        row = box.row()\r\n        row.scale_y = 1.5\r\n        row.operator(\&quot;bst.set_viewport_colors\&quot;)\r\n        \r\n        # Show progress if processing\r\n        if is_processing:\r\n            row = box.row()\r\n            row.label(text=f\&quot;Processing: {processed_count}/{total_materials}\&quot;)\r\n            \r\n            # Add a progress bar\r\n            row = box.row()\r\n            row.prop(context.scene, \&quot;viewport_colors_progress\&quot;, text=\&quot;\&quot;)\r\n        \r\n        # Show material results if available\r\n        if material_results:\r\n            box.separator()\r\n            row = box.row()\r\n            row.prop(context.scene, \&quot;show_material_results\&quot;, \r\n                     icon=&#39;DISCLOSURE_TRI_DOWN&#39; if context.scene.show_material_results else &#39;DISCLOSURE_TRI_RIGHT&#39;,\r\n                     emboss=False)\r\n            row.label(text=\&quot;Material Results:\&quot;)\r\n            if context.scene.show_material_results:\r\n                # Create a scrollable list\r\n                material_box = box.box()\r\n                row = material_box.row()\r\n                col = row.column()\r\n                \r\n                # Collect materials to remove\r\n                materials_to_remove = []\r\n                \r\n                # Count materials by status\r\n                preview_count = 0\r\n                failed_count = 0\r\n                \r\n                # Display material results - use a copy of the keys to avoid modification during iteration\r\n                for material_name in list(material_results.keys()):\r\n                    color, status = material_results[material_name]\r\n                    \r\n                    # Update counts\r\n                    if status == MaterialStatus.PREVIEW_BASED:\r\n                        preview_count += 1\r\n                    elif status == MaterialStatus.FAILED:\r\n                        failed_count += 1\r\n                    \r\n                    row = col.row(align=True)\r\n                    \r\n                    # Add status icon\r\n                    row.label(text=\&quot;\&quot;, icon=get_status_icon(status))\r\n                    \r\n                    # Add material name with operator to select it\r\n                    op = row.operator(\&quot;bst.select_in_editor\&quot;, text=material_name)\r\n                    op.material_name = material_name\r\n                    \r\n                    # Add color preview\r\n                    if color:\r\n                        material = bpy.data.materials.get(material_name)\r\n                        if material:  # Check if material still exists\r\n                            row.prop(material, \&quot;diffuse_color\&quot;, text=\&quot;\&quot;)\r\n                        else:\r\n                            # Material no longer exists, show a placeholder color\r\n                            row.label(text=\&quot;\&quot;, icon=&#39;ERROR&#39;)\r\n                            # Mark for removal\r\n                            materials_to_remove.append(material_name)\r\n                \r\n                # Remove materials that no longer exist\r\n                for material_name in materials_to_remove:\r\n                    material_results.pop(material_name, None)\r\n                \r\n                # Show statistics\r\n                if len(material_results) &gt; 0:\r\n                    material_box.separator()\r\n                    stats_col = material_box.column(align=True)\r\n                    stats_col.label(text=f\&quot;Total: {len(material_results)} materials\&quot;)\r\n                    stats_col.label(text=f\&quot;Thumbnail-based: {preview_count}\&quot;)\r\n                    stats_col.label(text=f\&quot;Failed: {failed_count}\&quot;)\r\n\r\n        # Add the select diffuse nodes button at the bottom\r\n        layout.separator()\r\n        layout.operator(\&quot;bst.select_diffuse_nodes\&quot;, icon=&#39;NODE_TEXTURE&#39;)\r\n\r\nclass MATERIAL_OT_SelectInEditor(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Select this material in the editor\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.select_in_editor\&quot;\r\n    bl_label = \&quot;Select Material\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n    \r\n    material_name: bpy.props.StringProperty(  # type: ignore\r\n        name=\&quot;Material Name\&quot;,\r\n        description=\&quot;Name of the material to select\&quot;,\r\n        default=\&quot;\&quot;\r\n    )\r\n    \r\n    def execute(self, context):\r\n        # Find the material\r\n        material = bpy.data.materials.get(self.material_name)\r\n        if not material:\r\n            # Remove this entry from material_results to avoid future errors\r\n            if self.material_name in material_results:\r\n                material_results.pop(self.material_name, None)\r\n                # Force a redraw of the UI\r\n                for area in context.screen.areas:\r\n                    area.tag_redraw()\r\n            self.report({&#39;ERROR&#39;}, f\&quot;Material &#39;{self.material_name}&#39; not found\&quot;)\r\n            return {&#39;CANCELLED&#39;}\r\n        \r\n        # Find an object using this material\r\n        for obj in bpy.data.objects:\r\n            if obj.type == &#39;MESH&#39; and obj.data.materials:\r\n                for i, mat in enumerate(obj.data.materials):\r\n                    if mat == material:\r\n                        # Select the object\r\n                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)\r\n                        obj.select_set(True)\r\n                        context.view_layer.objects.active = obj\r\n                        \r\n                        # Set the active material index\r\n                        obj.active_material_index = i\r\n                        \r\n                        # Switch to material properties\r\n                        for area in context.screen.areas:\r\n                            if area.type == &#39;PROPERTIES&#39;:\r\n                                for space in area.spaces:\r\n                                    if space.type == &#39;PROPERTIES&#39;:\r\n                                        space.context = &#39;MATERIAL&#39;\r\n                        \r\n                        return {&#39;FINISHED&#39;}\r\n        \r\n        self.report({&#39;WARNING&#39;}, f\&quot;No object using material &#39;{self.material_name}&#39; found\&quot;)\r\n        return {&#39;CANCELLED&#39;}\r\n\r\ndef get_color_from_preview(material, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Extract the average color from a material thumbnail\&quot;\&quot;\&quot;\r\n    if not material:\r\n        return None\r\n    \r\n    # Force Blender to generate the material preview if it doesn&#39;t exist\r\n    # This uses Blender&#39;s internal preview generation system\r\n    preview = material.preview\r\n    if not preview:\r\n        return None\r\n    \r\n    # Ensure the preview is generated (this should be very fast as Blender maintains these)\r\n    if preview.icon_id == 0:\r\n        # Use Blender&#39;s standard preview size\r\n        preview.icon_size = (128, 128)\r\n        # This triggers Blender&#39;s internal preview generation\r\n        icon_id = preview.icon_id  # Store in variable instead of just accessing\r\n    \r\n    # Access the preview image data - these are the same thumbnails shown in the material panel\r\n    preview_image = preview.icon_pixels_float\r\n    \r\n    if not preview_image or len(preview_image) == 0:\r\n        return None\r\n    \r\n    if use_vectorized and np is not None:\r\n        # Use NumPy for faster processing\r\n        pixels_np = np.array(preview_image)\r\n        \r\n        # Reshape to RGBA format (preview is stored as a flat RGBA array)\r\n        pixels_np = pixels_np.reshape(-1, 4)\r\n        \r\n        # Calculate average color (ignoring alpha and any pure black pixels which are often the background)\r\n        # Filter out black pixels (background) by checking if R+G+B is very small\r\n        non_black_mask = np.sum(pixels_np[:, :3], axis=1) &gt; 0.05\r\n        \r\n        if np.any(non_black_mask):\r\n            # Only use non-black pixels for the average\r\n            avg_color = pixels_np[non_black_mask][:, :3].mean(axis=0)\r\n            return avg_color.tolist()\r\n        else:\r\n            # If all pixels are black, return the average of all pixels\r\n            avg_color = pixels_np[:, :3].mean(axis=0)\r\n            return avg_color.tolist()\r\n    else:\r\n        # Fallback to pure Python\r\n        total_r, total_g, total_b = 0, 0, 0\r\n        pixel_count = 0\r\n        non_black_count = 0\r\n        \r\n        # Process pixels in groups of 4 (RGBA)\r\n        for i in range(0, len(preview_image), 4):\r\n            r, g, b, a = preview_image[i:i+4]\r\n            \r\n            # Skip black pixels (background)\r\n            if r + g + b &gt; 0.05:\r\n                total_r += r\r\n                total_g += g\r\n                total_b += b\r\n                non_black_count += 1\r\n            \r\n            pixel_count += 1\r\n        \r\n        # If we found non-black pixels, use their average\r\n        if non_black_count &gt; 0:\r\n            return [total_r / non_black_count, total_g / non_black_count, total_b / non_black_count]\r\n        # Otherwise, use the average of all pixels\r\n        elif pixel_count &gt; 0:\r\n            return [total_r / pixel_count, total_g / pixel_count, total_b / pixel_count]\r\n        else:\r\n            return None\r\n\r\nclass VIEWPORT_OT_SelectDiffuseNodes(bpy.types.Operator):\r\n    bl_idname = \&quot;bst.select_diffuse_nodes\&quot;\r\n    bl_label = \&quot;Set Texture Display\&quot;\r\n    bl_description = \&quot;Select the most relevant diffuse/base color image texture node in each material\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n\r\n    def execute(self, context):\r\n        if select_diffuse_nodes:\r\n            select_diffuse_nodes()\r\n            self.report({&#39;INFO&#39;}, \&quot;Diffuse/BaseColor image nodes selected.\&quot;)\r\n        else:\r\n            self.report({&#39;ERROR&#39;}, \&quot;select_diffuse_nodes function not found.\&quot;)\r\n        return {&#39;FINISHED&#39;}\r\n\r\n# List of all classes in this module\r\nclasses = (\r\n    VIEWPORT_OT_SetViewportColors,\r\n    VIEWPORT_OT_RefreshMaterialPreviews,\r\n    VIEW3D_PT_BulkViewportDisplay,\r\n    MATERIAL_OT_SelectInEditor,\r\n    VIEWPORT_OT_SelectDiffuseNodes,\r\n)\r\n\r\n# Registration\r\ndef register():\r\n    for cls in classes:\r\n        bpy.utils.register_class(cls)\r\n    \r\n    # Register properties\r\n    register_viewport_properties()\r\n\r\ndef unregister():\r\n    # Unregister properties\r\n    try:\r\n        unregister_viewport_properties()\r\n    except Exception:\r\n        pass\r\n    # Unregister classes\r\n    for cls in reversed(classes):\r\n        try:\r\n            bpy.utils.unregister_class(cls)\r\n        except RuntimeError:\r\n            pass &quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating task statuses for property removal**</details></think>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Create operator to refresh material previews
- [x] Remove refresh property from scene + logic
- [x] Draw refresh button in viewport panel

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Running lint checks**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `panels/bulk_viewport_display.py`

Lint results


**No lint errors found**
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing final summary response**</details></think>

---

Refresh now sits behind a dedicated operator instead of an always-on toggle, so you can regenerate thumbnails on demand but still skip the upfront cost when you don’t need it ([Issue #7](https://github.com/RaincloudTheDragon/Rainys-Bulk-Scene-Tools/issues/7)).

- Added `VIEWPORT_OT_RefreshMaterialPreviews` to wrap the three preview ops with basic success/failure reporting, and registered it with the rest of the panel classes.  
```244:270:panels/bulk_viewport_display.py
class VIEWPORT_OT_RefreshMaterialPreviews(bpy.types.Operator):
    """Regenerate material previews to avoid stale thumbnails"""
    bl_idname = "bst.refresh_material_previews"
    bl_label = "Refresh Material Previews"
    bl_options = {'REGISTER'}

    def execute(self, context):
        try:
            bpy.ops.wm.previews_clear()
            bpy.ops.wm.previews_batch_generate()
            bpy.ops.wm.previews_ensure()
        except Exception as exc:
            self.report({'WARNING'}, f"Preview refresh failed: {exc}")
            return {'CANCELLED'}

        self.report({'INFO'}, "Material previews refreshed")
        return {'FINISHED'}
```

- Removed the now-unneeded scene property and its unregister cleanup to keep the API lean.  
```82:109:panels/bulk_viewport_display.py
    bpy.types.Scene.viewport_colors_use_preview = bpy.props.BoolProperty(  # type: ignore
        name="Use Material Thumbnails",
        description="Use Blender's material thumbnails for color extraction (faster and more reliable)",
        default=True
    )

def unregister_viewport_properties():
    del bpy.types.Scene.viewport_colors_use_preview
    del bpy.types.Scene.viewport_colors_batch_size
    del bpy.types.Scene.viewport_colors_use_vectorized
    del bpy.types.Scene.viewport_colors_darken_amount
    del bpy.types.Scene.viewport_colors_value_amount
    del bpy.types.Scene.viewport_colors_progress
```

- Drew the new button next to the primary viewport-color controls so users can refresh right before running Set Viewport Colors without digging elsewhere.  
```698:737:panels/bulk_viewport_display.py
        col = box.column(align=True)
        col.prop(context.scene, "viewport_colors_selected_only")
        col.operator("bst.refresh_material_previews", icon='FILE_REFRESH')
```

No automated Blender tests were run; please click the new Refresh Material Previews button in the UI to confirm it regenerates thumbnails before running Set Viewport Colors.

---

_**User (2025-11-27 07:04Z)**_

there are still some materials that aren't generating thumbnails. I know there's some way to force it to regenerate it.

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Preparing clarification questions**</details></think>

---

1. Should we force previews by assigning each material to a temporary object and triggering Blender’s internal preview render (e.g., via `material.preview_render_type`/`preview_ensure`), or do you have a different regeneration method in mind?

---

_**User (2025-11-27 07:04Z)**_

yes, let's do that precisely.

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Planning material preview forcing**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  &quot;pattern&quot;: &quot;preview_render&quot;,
  &quot;path&quot;: &quot;.&quot;,
  &quot;outputMode&quot;: &quot;content&quot;,
  &quot;caseInsensitive&quot;: false
}
```
Result:

```json
{
  &quot;success&quot;: {
    &quot;pattern&quot;: &quot;preview_render&quot;,
    &quot;path&quot;: &quot;.&quot;,
    &quot;outputMode&quot;: &quot;content&quot;,
    &quot;workspaceResults&quot;: {
      &quot;d:/Rainys-Bulk-Scene-Tools&quot;: {
        &quot;content&quot;: {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning mesh preview creation**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="rg">
<details>
<summary>Tool use: **rg**</summary>


Parameters:

```json
{
  &quot;pattern&quot;: &quot;preview_ensure&quot;,
  &quot;path&quot;: &quot;.&quot;,
  &quot;outputMode&quot;: &quot;content&quot;,
  &quot;caseInsensitive&quot;: false
}
```
Result:

```json
{
  &quot;success&quot;: {
    &quot;pattern&quot;: &quot;preview_ensure&quot;,
    &quot;path&quot;: &quot;.&quot;,
    &quot;outputMode&quot;: &quot;content&quot;,
    &quot;workspaceResults&quot;: {
      &quot;d:/Rainys-Bulk-Scene-Tools&quot;: {
        &quot;content&quot;: {
          &quot;matches&quot;: [
            {
              &quot;file&quot;: &quot;.\\panels\\bulk_path_management.py&quot;,
              &quot;matches&quot;: [
                {
                  &quot;lineNumber&quot;: 1558,
                  &quot;content&quot;: &quot;                        row.template_icon(icon_value=img.preview_ensure().icon_id, scale=1.0)&quot;
                }
              ]
            },
            {
              &quot;file&quot;: &quot;.\\panels\\bulk_data_remap.py&quot;,
              &quot;matches&quot;: [
                {
                  &quot;lineNumber&quot;: 931,
                  &quot;content&quot;: &quot;                    row.template_icon(icon_value=target_item.preview_ensure().icon_id, scale=1.0)&quot;
                },
                {
                  &quot;lineNumber&quot;: 968,
                  &quot;content&quot;: &quot;                            sub_row.template_icon(icon_value=item.preview_ensure().icon_id, scale=1.0)&quot;
                }
              ]
            }
          ],
          &quot;totalLines&quot;: 3,
          &quot;totalMatchedLines&quot;: 3
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Designing forced material preview generation**

I'm working out a detailed plan to force Blender materials' previews to render by creating a temporary mesh object, assigning each material to it, and invoking preview-related calls like `preview_ensure()` and setting `preview_render_type`. I want to handle edge cases, clean up after, and integrate this logic into the refresh operator to work around the known preview rendering stall bug.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;panels/bulk_viewport_display.py&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;6fe26dcd-8d73-4a31-ac0c-83cbcb11990c&quot;
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  \r\n      def execute(self, context):\r\n+         forced_count = 0\r\n          try:\r\n              bpy.ops.wm.previews_clear()\r\n              bpy.ops.wm.previews_batch_generate()\r\n              bpy.ops.wm.previews_ensure()\r\n          except Exception as exc:\r\n-             self.report({&#39;WARNING&#39;}, f\&quot;Preview refresh failed: {exc}\&quot;)\r\n-             return {&#39;CANCELLED&#39;}\r\n- \r\n-         self.report({&#39;INFO&#39;}, \&quot;Material previews refreshed\&quot;)\r\n+             self.report({&#39;WARNING&#39;}, f\&quot;Pre-clearing previews failed: {exc}\&quot;)\r\n+         \r\n+         temp_obj = self._create_preview_object(context)\r\n+         \r\n+         try:\r\n+             for material in bpy.data.materials:\r\n+                 if not material or material.is_grease_pencil:\r\n+                     continue\r\n+                 \r\n+                 try:\r\n+                     self._force_preview(material, temp_obj)\r\n+                     forced_count += 1\r\n+                 except Exception as exc:\r\n+                     print(f\&quot;BST preview refresh: failed for {material.name}: {exc}\&quot;)\r\n+         finally:\r\n+             self._cleanup_preview_object(temp_obj)\r\n+ \r\n+         message = f\&quot;Material previews refreshed ({forced_count} materials)\&quot;\r\n+         self.report({&#39;INFO&#39;}, message)\r\n          return {&#39;FINISHED&#39;}\r\n  \r\n+     def _create_preview_object(self, context):\r\n+         mesh = bpy.data.meshes.new(\&quot;BST_PreviewMesh\&quot;)\r\n+         mesh.from_pydata(\r\n+             [(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)],\r\n+             [],\r\n+             [(0, 1, 2), (0, 2, 3), (0, 3, 1), (1, 3, 2)]\r\n+         )\r\n+         obj = bpy.data.objects.new(\&quot;BST_PreviewObject\&quot;, mesh)\r\n+         obj.hide_viewport = True\r\n+         obj.hide_render = True\r\n+         context.scene.collection.objects.link(obj)\r\n+         return obj\r\n+ \r\n+     def _cleanup_preview_object(self, obj):\r\n+         if not obj:\r\n+             return\r\n+         mesh = obj.data\r\n+         bpy.data.objects.remove(obj, do_unlink=True)\r\n+         if mesh:\r\n+             bpy.data.meshes.remove(mesh, do_unlink=True)\r\n+ \r\n+     def _force_preview(self, material, temp_obj):\r\n+         if temp_obj.data.materials:\r\n+             temp_obj.data.materials[0] = material\r\n+         else:\r\n+             temp_obj.data.materials.append(material)\r\n+         material.preview_render_type = &#39;SPHERE&#39;\r\n+         preview = material.preview_ensure()\r\n+         if preview:\r\n+             # Touch icon id to ensure generation\r\n+             _ = preview.icon_id\r\n+ \r\n  \r\n  def correct_viewport_color(color):\r&quot;,
        &quot;oldStart&quot;: 275,
        &quot;newStart&quot;: 275,
        &quot;oldLines&quot;: 15,
        &quot;newLines&quot;: 63,
        &quot;linesRemoved&quot;: 4,
        &quot;linesAdded&quot;: 52
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM panels/bulk_viewport_display.py&quot;,
  &quot;contentsAfterEdit&quot;: &quot;import bpy # type: ignore\r\nimport numpy as np\r\nfrom time import time\r\nimport os\r\nfrom enum import Enum\r\nimport colorsys  # Add colorsys for RGB to HSV conversion\r\nfrom ..ops.select_diffuse_nodes import select_diffuse_nodes  # Import the specific function\r\n\r\n# Material processing status enum\r\nclass MaterialStatus(Enum):\r\n    PENDING = 0\r\n    PROCESSING = 1\r\n    COMPLETED = 2\r\n    FAILED = 3\r\n    PREVIEW_BASED = 4\r\n\r\n# Global variables to store results and track progress\r\nmaterial_results = {}  # {material_name: (color, status)}\r\ncurrent_material = \&quot;\&quot;\r\nprocessed_count = 0\r\ntotal_materials = 0\r\nstart_time = 0\r\nis_processing = False\r\nmaterial_queue = []\r\ncurrent_index = 0\r\n\r\n# Scene properties for viewport display settings\r\ndef register_viewport_properties():\r\n    bpy.types.Scene.viewport_colors_selected_only = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Selected Objects Only\&quot;,\r\n        description=\&quot;Apply viewport colors only to materials in selected objects\&quot;,\r\n        default=False\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_batch_size = bpy.props.IntProperty(  # type: ignore\r\n        name=\&quot;Batch Size\&quot;,\r\n        description=\&quot;Number of materials to process in each batch\&quot;,\r\n        default=50,\r\n        min=1,\r\n        max=50\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_use_vectorized = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Use Vectorized Processing\&quot;,\r\n        description=\&quot;Use vectorized operations for image processing (faster but uses more memory)\&quot;,\r\n        default=True\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_darken_amount = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Color Adjustment\&quot;,\r\n        description=\&quot;Adjust viewport colors by ±10% (+1 = +10% lighter, 0 = no change, -1 = -10% darker)\&quot;,\r\n        default=0.0,\r\n        min=-1.0,\r\n        max=1.0,\r\n        subtype=&#39;FACTOR&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_value_amount = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Saturation Adjustment\&quot;,\r\n        description=\&quot;Adjust color saturation by ±10% (+1 = +10% more saturated, 0 = no change, -1 = -10% less saturated)\&quot;,\r\n        default=1.0,\r\n        min=-1.0,\r\n        max=1.0,\r\n        subtype=&#39;FACTOR&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_progress = bpy.props.FloatProperty(  # type: ignore\r\n        name=\&quot;Progress\&quot;,\r\n        description=\&quot;Progress of the viewport color setting operation\&quot;,\r\n        default=0.0,\r\n        min=0.0,\r\n        max=100.0,\r\n        subtype=&#39;PERCENTAGE&#39;\r\n    )\r\n    \r\n    bpy.types.Scene.viewport_colors_show_advanced = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Show Advanced Options\&quot;,\r\n        description=\&quot;Show advanced options for viewport color extraction\&quot;,\r\n        default=False\r\n    )\r\n    \r\n    # New properties for thumbnail-based color extraction\r\n    bpy.types.Scene.viewport_colors_use_preview = bpy.props.BoolProperty(  # type: ignore\r\n        name=\&quot;Use Material Thumbnails\&quot;,\r\n        description=\&quot;Use Blender&#39;s material thumbnails for color extraction (faster and more reliable)\&quot;,\r\n        default=True\r\n    )\r\n\r\n    bpy.types.Scene.show_material_results = bpy.props.BoolProperty(\r\n        name=\&quot;\&quot;,\r\n        description=\&quot;Show material results in the viewport display panel\&quot;,\r\n        default=True\r\n    )\r\n\r\ndef unregister_viewport_properties():\r\n    del bpy.types.Scene.viewport_colors_use_preview\r\n    del bpy.types.Scene.viewport_colors_batch_size\r\n    del bpy.types.Scene.viewport_colors_use_vectorized\r\n    del bpy.types.Scene.viewport_colors_darken_amount\r\n    del bpy.types.Scene.viewport_colors_value_amount\r\n    del bpy.types.Scene.viewport_colors_progress\r\n    del bpy.types.Scene.viewport_colors_selected_only\r\n    del bpy.types.Scene.viewport_colors_show_advanced\r\n    del bpy.types.Scene.show_material_results\r\n\r\nclass VIEWPORT_OT_SetViewportColors(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Set Viewport Display colors from BSDF base color or texture\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.set_viewport_colors\&quot;\r\n    bl_label = \&quot;Set Viewport Colors\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n    \r\n    def execute(self, context):\r\n        global material_results, current_material, processed_count, total_materials, start_time, is_processing, material_queue, current_index\r\n        \r\n        # Reset global variables\r\n        material_results = {}\r\n        current_material = \&quot;\&quot;\r\n        processed_count = 0\r\n        is_processing = True\r\n        start_time = time()\r\n        current_index = 0\r\n        \r\n        # Get materials based on selection mode\r\n        if context.scene.viewport_colors_selected_only:\r\n            # Get materials from selected objects only\r\n            materials = []\r\n            for obj in context.selected_objects:\r\n                if obj.type == &#39;MESH&#39; and obj.data.materials:\r\n                    for mat in obj.data.materials:\r\n                        if mat and not mat.is_grease_pencil and mat not in materials:\r\n                            materials.append(mat)\r\n        else:\r\n            # Get all materials in the scene\r\n            materials = [mat for mat in bpy.data.materials if not mat.is_grease_pencil]\r\n        \r\n        total_materials = len(materials)\r\n        material_queue = materials.copy()\r\n        \r\n        if total_materials == 0:\r\n            self.report({&#39;WARNING&#39;}, \&quot;No materials found to process\&quot;)\r\n            is_processing = False\r\n            return {&#39;CANCELLED&#39;}\r\n        \r\n        # Reset progress\r\n        context.scene.viewport_colors_progress = 0.0\r\n        \r\n        # Start a timer to process materials in batches\r\n        bpy.app.timers.register(self._process_batch)\r\n        \r\n        return {&#39;FINISHED&#39;}\r\n    \r\n    def _process_batch(self):\r\n        global material_results, current_material, processed_count, total_materials, is_processing, material_queue, current_index\r\n        \r\n        if not is_processing or len(material_queue) == 0:\r\n            is_processing = False\r\n            self.report_info()\r\n            return None\r\n        \r\n        # Get the batch size from scene properties\r\n        batch_size = bpy.context.scene.viewport_colors_batch_size\r\n        use_vectorized = bpy.context.scene.viewport_colors_use_vectorized\r\n        \r\n        # Process a batch of materials\r\n        batch_end = min(current_index + batch_size, len(material_queue))\r\n        batch = material_queue[current_index:batch_end]\r\n        \r\n        for material in batch:\r\n            # Skip if material is invalid or has been deleted\r\n            if material is None or material.name not in bpy.data.materials:\r\n                processed_count += 1\r\n                continue\r\n                \r\n            current_material = material.name\r\n            \r\n            # Process the material\r\n            color, status = process_material(material, use_vectorized)\r\n            \r\n            # Apply the color to the material\r\n            if color:\r\n                # Store the color change to apply later in main thread\r\n                material_results[material.name] = (color, status)\r\n                # Mark this material for color application\r\n                if not hasattr(self, &#39;pending_color_changes&#39;):\r\n                    self.pending_color_changes = []\r\n                self.pending_color_changes.append((material, color))\r\n            else:\r\n                # Store the result without color change\r\n                material_results[material.name] = (None, status)\r\n            \r\n            # Update processed count\r\n            processed_count += 1\r\n            \r\n            # Update progress\r\n            if total_materials &gt; 0:\r\n                bpy.context.scene.viewport_colors_progress = (processed_count / total_materials) * 100\r\n        \r\n        # Update the current index\r\n        current_index = batch_end\r\n        \r\n        # Force a redraw of the UI\r\n        for area in bpy.context.screen.areas:\r\n            area.tag_redraw()\r\n        \r\n        # Check if we&#39;re done\r\n        if current_index &gt;= len(material_queue):\r\n            is_processing = False\r\n            # Apply pending color changes in main thread\r\n            if hasattr(self, &#39;pending_color_changes&#39;) and self.pending_color_changes:\r\n                bpy.app.timers.register(self._apply_color_changes)\r\n            self.report_info()\r\n            return None\r\n        \r\n        # Continue processing\r\n        return 0.1  # Check again in 0.1 seconds\r\n    \r\n    def _apply_color_changes(self):\r\n        \&quot;\&quot;\&quot;Apply pending color changes in the main thread\&quot;\&quot;\&quot;\r\n        if not hasattr(self, &#39;pending_color_changes&#39;) or not self.pending_color_changes:\r\n            return None\r\n        \r\n        # Apply a batch of color changes\r\n        batch_size = 10  # Process 10 materials at a time\r\n        batch = self.pending_color_changes[:batch_size]\r\n        \r\n        for material, color in batch:\r\n            try:\r\n                if material and material.name in bpy.data.materials:\r\n                    material.diffuse_color = (*color, 1.0)\r\n            except Exception as e:\r\n                print(f\&quot;Could not set diffuse_color for {material.name if material else &#39;Unknown&#39;}: {e}\&quot;)\r\n        \r\n        # Remove processed items\r\n        self.pending_color_changes = self.pending_color_changes[batch_size:]\r\n        \r\n        # Continue if there are more to process\r\n        if self.pending_color_changes:\r\n            return 0.01  # Process next batch in 0.01 seconds\r\n        \r\n        # All done\r\n        print(f\&quot;Applied viewport colors to {len(batch)} materials\&quot;)\r\n        return None\r\n    \r\n    def report_info(self):\r\n        global processed_count, start_time\r\n        elapsed_time = time() - start_time\r\n        \r\n        # Count materials by status\r\n        preview_count = 0\r\n        node_count = 0\r\n        failed_count = 0\r\n        \r\n        for _, status in material_results.values():\r\n            if status == MaterialStatus.PREVIEW_BASED:\r\n                preview_count += 1\r\n            elif status == MaterialStatus.COMPLETED:\r\n                node_count += 1\r\n            elif status == MaterialStatus.FAILED:\r\n                failed_count += 1\r\n        \r\n        # Use a popup menu instead of self.report since this might be called from a timer\r\n        def draw_popup(self, context):\r\n            self.layout.label(text=f\&quot;Processed {processed_count} materials in {elapsed_time:.2f} seconds\&quot;)\r\n            self.layout.label(text=f\&quot;Thumbnail-based: {preview_count}, Node-based: {node_count}\&quot;)\r\n            self.layout.label(text=f\&quot;Failed: {failed_count}\&quot;)\r\n        \r\n        bpy.context.window_manager.popup_menu(draw_popup, title=\&quot;Processing Complete\&quot;, icon=&#39;INFO&#39;)\r\n\r\n\r\nclass VIEWPORT_OT_RefreshMaterialPreviews(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Regenerate material previews to avoid stale thumbnails\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.refresh_material_previews\&quot;\r\n    bl_label = \&quot;Refresh Material Previews\&quot;\r\n    bl_options = {&#39;REGISTER&#39;}\r\n\r\n    def execute(self, context):\r\n        forced_count = 0\r\n        try:\r\n            bpy.ops.wm.previews_clear()\r\n            bpy.ops.wm.previews_batch_generate()\r\n            bpy.ops.wm.previews_ensure()\r\n        except Exception as exc:\r\n            self.report({&#39;WARNING&#39;}, f\&quot;Pre-clearing previews failed: {exc}\&quot;)\r\n        \r\n        temp_obj = self._create_preview_object(context)\r\n        \r\n        try:\r\n            for material in bpy.data.materials:\r\n                if not material or material.is_grease_pencil:\r\n                    continue\r\n                \r\n                try:\r\n                    self._force_preview(material, temp_obj)\r\n                    forced_count += 1\r\n                except Exception as exc:\r\n                    print(f\&quot;BST preview refresh: failed for {material.name}: {exc}\&quot;)\r\n        finally:\r\n            self._cleanup_preview_object(temp_obj)\r\n\r\n        message = f\&quot;Material previews refreshed ({forced_count} materials)\&quot;\r\n        self.report({&#39;INFO&#39;}, message)\r\n        return {&#39;FINISHED&#39;}\r\n\r\n    def _create_preview_object(self, context):\r\n        mesh = bpy.data.meshes.new(\&quot;BST_PreviewMesh\&quot;)\r\n        mesh.from_pydata(\r\n            [(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)],\r\n            [],\r\n            [(0, 1, 2), (0, 2, 3), (0, 3, 1), (1, 3, 2)]\r\n        )\r\n        obj = bpy.data.objects.new(\&quot;BST_PreviewObject\&quot;, mesh)\r\n        obj.hide_viewport = True\r\n        obj.hide_render = True\r\n        context.scene.collection.objects.link(obj)\r\n        return obj\r\n\r\n    def _cleanup_preview_object(self, obj):\r\n        if not obj:\r\n            return\r\n        mesh = obj.data\r\n        bpy.data.objects.remove(obj, do_unlink=True)\r\n        if mesh:\r\n            bpy.data.meshes.remove(mesh, do_unlink=True)\r\n\r\n    def _force_preview(self, material, temp_obj):\r\n        if temp_obj.data.materials:\r\n            temp_obj.data.materials[0] = material\r\n        else:\r\n            temp_obj.data.materials.append(material)\r\n        material.preview_render_type = &#39;SPHERE&#39;\r\n        preview = material.preview_ensure()\r\n        if preview:\r\n            # Touch icon id to ensure generation\r\n            _ = preview.icon_id\r\n\r\n\r\ndef correct_viewport_color(color):\r\n    \&quot;\&quot;\&quot;Adjust viewport colors by color intensity and saturation\&quot;\&quot;\&quot;\r\n    r, g, b = color\r\n    \r\n    # Get the color adjustment amount (-1 to +1) and scale it to ±10%\r\n    color_adjustment = bpy.context.scene.viewport_colors_darken_amount * 0.1\r\n    \r\n    # Get the saturation adjustment amount (-1 to +1) and scale it to ±10%\r\n    saturation_adjustment = bpy.context.scene.viewport_colors_value_amount * 0.1\r\n    \r\n    # First apply the color adjustment (RGB)\r\n    r = r + color_adjustment\r\n    g = g + color_adjustment\r\n    b = b + color_adjustment\r\n    \r\n    # Clamp RGB values after color adjustment\r\n    r = max(0.0, min(1.0, r))\r\n    g = max(0.0, min(1.0, g))\r\n    b = max(0.0, min(1.0, b))\r\n    \r\n    # Then apply the saturation adjustment using HSV\r\n    if saturation_adjustment != 0:\r\n        # Convert to HSV\r\n        h, s, v = colorsys.rgb_to_hsv(r, g, b)\r\n        \r\n        # Adjust saturation while preserving hue and value\r\n        s = s + saturation_adjustment\r\n        s = max(0.0, min(1.0, s))\r\n        \r\n        # Convert back to RGB\r\n        r, g, b = colorsys.hsv_to_rgb(h, s, v)\r\n    \r\n    return (r, g, b)\r\n\r\ndef process_material(material, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Process a material to determine its viewport color\&quot;\&quot;\&quot;\r\n    if not material:\r\n        print(f\&quot;Material is None, using fallback color\&quot;)\r\n        return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n    \r\n    if material.is_grease_pencil:\r\n        print(f\&quot;Material {material.name}: is a grease pencil material, using fallback color\&quot;)\r\n        return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n    \r\n    try:\r\n        # Get color from material thumbnail\r\n        print(f\&quot;Material {material.name}: Attempting to extract color from thumbnail\&quot;)\r\n        \r\n        # Get color from the material thumbnail\r\n        color = get_color_from_preview(material, use_vectorized)\r\n        \r\n        if color:\r\n            print(f\&quot;Material {material.name}: Thumbnail color = {color}\&quot;)\r\n            \r\n            # Correct color for viewport display\r\n            corrected_color = correct_viewport_color(color)\r\n            print(f\&quot;Material {material.name}: Corrected thumbnail color = {corrected_color}\&quot;)\r\n            \r\n            return corrected_color, MaterialStatus.PREVIEW_BASED\r\n        else:\r\n            print(f\&quot;Material {material.name}: Could not extract color from thumbnail, using fallback color\&quot;)\r\n            return (1, 1, 1), MaterialStatus.PREVIEW_BASED\r\n        \r\n    except Exception as e:\r\n        print(f\&quot;Error processing material {material.name}: {e}\&quot;)\r\n        return (1, 1, 1), MaterialStatus.FAILED\r\n\r\ndef get_average_color(image, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Calculate the average color of an image\&quot;\&quot;\&quot;\r\n    if not image or not image.has_data:\r\n        return None\r\n    \r\n    # Get image pixels\r\n    pixels = list(image.pixels)\r\n    \r\n    if use_vectorized and np is not None:\r\n        # Use NumPy for faster processing\r\n        pixels_np = np.array(pixels)\r\n        \r\n        # Reshape to RGBA format\r\n        pixels_np = pixels_np.reshape(-1, 4)\r\n        \r\n        # Calculate average color (ignoring alpha)\r\n        avg_color = pixels_np[:, :3].mean(axis=0)\r\n        \r\n        return avg_color.tolist()\r\n    else:\r\n        # Fallback to pure Python\r\n        total_r, total_g, total_b = 0, 0, 0\r\n        pixel_count = len(pixels) // 4\r\n        \r\n        for i in range(0, len(pixels), 4):\r\n            total_r += pixels[i]\r\n            total_g += pixels[i+1]\r\n            total_b += pixels[i+2]\r\n        \r\n        if pixel_count &gt; 0:\r\n            return [total_r / pixel_count, total_g / pixel_count, total_b / pixel_count]\r\n        else:\r\n            return None\r\n\r\ndef find_image_node(node, visited=None):\r\n    \&quot;\&quot;\&quot;Find the first image node connected to the given node\&quot;\&quot;\&quot;\r\n    if visited is None:\r\n        visited = set()\r\n    \r\n    if node in visited:\r\n        return None\r\n    \r\n    visited.add(node)\r\n    \r\n    # Check if this is an image node\r\n    if node.type == &#39;TEX_IMAGE&#39; and node.image:\r\n        return node\r\n    \r\n    # Check input connections\r\n    for input_socket in node.inputs:\r\n        for link in input_socket.links:\r\n            from_node = link.from_node\r\n            result = find_image_node(from_node, visited)\r\n            if result:\r\n                return result\r\n    \r\n    return None\r\n\r\ndef find_color_source(node, socket_name=None, visited=None):\r\n    \&quot;\&quot;\&quot;\r\n    Recursively trace color data through nodes to find the source\r\n    This is an enhanced version that handles mix nodes and node groups\r\n    \&quot;\&quot;\&quot;\r\n    if visited is None:\r\n        visited = set()\r\n    \r\n    # Avoid infinite recursion\r\n    node_id = (node, socket_name)\r\n    if node_id in visited:\r\n        return None, None\r\n    \r\n    visited.add(node_id)\r\n    \r\n    # Handle different node types\r\n    if node.type == &#39;TEX_IMAGE&#39; and node.image:\r\n        # Direct image texture\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;RGB&#39;:\r\n        # Direct RGB color\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;VALTORGB&#39;:  # Color Ramp\r\n        return node, &#39;Color&#39;\r\n    \r\n    elif node.type == &#39;MIX_RGB&#39; or node.type == &#39;MIX&#39;:\r\n        # For mix nodes, check the factor to determine which input to prioritize\r\n        factor = 0.5  # Default to equal mix\r\n        \r\n        # Try to get the factor value\r\n        if len(node.inputs) &gt;= 1:\r\n            if hasattr(node.inputs[0], &#39;default_value&#39;):\r\n                factor = node.inputs[0].default_value\r\n        \r\n        # If factor is close to 0, prioritize the first color input\r\n        # If factor is close to 1, prioritize the second color input\r\n        # Otherwise, check both with second having slightly higher priority\r\n        \r\n        if factor &lt; 0.1:  # Strongly favor first input\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n            # Fallback to second input\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n        elif factor &gt; 0.9:  # Strongly favor second input\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n                    \r\n            # Fallback to first input\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n        else:\r\n            # Check both inputs with slight preference for the second input (usually the main color)\r\n            # First try Color2 (second input)\r\n            if len(node.inputs) &gt;= 3 and node.inputs[2].links:\r\n                color2_node = node.inputs[2].links[0].from_node\r\n                result_node, result_socket = find_color_source(color2_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n            \r\n            # Then try Color1 (first input)\r\n            if len(node.inputs) &gt;= 2 and node.inputs[1].links:\r\n                color1_node = node.inputs[1].links[0].from_node\r\n                result_node, result_socket = find_color_source(color1_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n    \r\n    elif node.type == &#39;GROUP&#39;:\r\n        # Handle node groups by finding the group output node and tracing back\r\n        if node.node_tree:\r\n            # Find output node in the group\r\n            for group_node in node.node_tree.nodes:\r\n                if group_node.type == &#39;GROUP_OUTPUT&#39;:\r\n                    # Find which input socket corresponds to the color output\r\n                    for i, output in enumerate(node.outputs):\r\n                        if output.links and (socket_name is None or output.name == socket_name):\r\n                            # Find the corresponding input in the group output node\r\n                            if i &lt; len(group_node.inputs) and group_node.inputs[i].links:\r\n                                input_link = group_node.inputs[i].links[0]\r\n                                source_node = input_link.from_node\r\n                                source_socket = input_link.from_socket.name\r\n                                return find_color_source(source_node, source_socket, visited)\r\n    \r\n    elif node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n        # If we somehow got to a principled BSDF node, check its base color input\r\n        base_color_input = node.inputs.get(&#39;Base Color&#39;)\r\n        if base_color_input and base_color_input.links:\r\n            connected_node = base_color_input.links[0].from_node\r\n            return find_color_source(connected_node, None, visited)\r\n    \r\n    # For shader nodes, try to find color inputs\r\n    elif &#39;BSDF&#39; in node.type or &#39;SHADER&#39; in node.type:\r\n        # Look for color inputs in shader nodes\r\n        color_input_names = [&#39;Color&#39;, &#39;Base Color&#39;, &#39;Diffuse Color&#39;, &#39;Tint&#39;]\r\n        for name in color_input_names:\r\n            input_socket = node.inputs.get(name)\r\n            if input_socket and input_socket.links:\r\n                connected_node = input_socket.links[0].from_node\r\n                result_node, result_socket = find_color_source(connected_node, None, visited)\r\n                if result_node:\r\n                    return result_node, result_socket\r\n    \r\n    # For other node types, check all inputs\r\n    for input_socket in node.inputs:\r\n        if input_socket.links:\r\n            from_node = input_socket.links[0].from_node\r\n            result_node, result_socket = find_color_source(from_node, None, visited)\r\n            if result_node:\r\n                return result_node, result_socket\r\n    \r\n    # If we get here, no color source was found\r\n    return None, None\r\n\r\ndef get_final_color(material):\r\n    \&quot;\&quot;\&quot;Get the final color for a material\&quot;\&quot;\&quot;\r\n    if not material or not material.use_nodes:\r\n        print(f\&quot;Material {material.name if material else &#39;None&#39;} has no nodes\&quot;)\r\n        return None\r\n    \r\n    # Find the Principled BSDF node\r\n    principled_node = None\r\n    for node in material.node_tree.nodes:\r\n        if node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n            principled_node = node\r\n            break\r\n    \r\n    if not principled_node:\r\n        print(f\&quot;Material {material.name}: No Principled BSDF node found\&quot;)\r\n        return None\r\n    \r\n    # Get the Base Color input\r\n    base_color_input = principled_node.inputs.get(&#39;Base Color&#39;)\r\n    if not base_color_input:\r\n        print(f\&quot;Material {material.name}: No Base Color input found\&quot;)\r\n        return None\r\n    \r\n    # Check if there&#39;s a texture connected to the Base Color input\r\n    if base_color_input.links:\r\n        connected_node = base_color_input.links[0].from_node\r\n        print(f\&quot;Material {material.name}: Base Color connected to {connected_node.name} of type {connected_node.type}\&quot;)\r\n        \r\n        # Use the enhanced color source finding function\r\n        source_node, source_socket = find_color_source(connected_node)\r\n        \r\n        if source_node:\r\n            print(f\&quot;Material {material.name}: Found color source node {source_node.name} of type {source_node.type}\&quot;)\r\n            \r\n            # Handle different source node types\r\n            if source_node.type == &#39;TEX_IMAGE&#39; and source_node.image:\r\n                print(f\&quot;Material {material.name}: Using image texture {source_node.image.name}\&quot;)\r\n                color = get_average_color(source_node.image)\r\n                if color:\r\n                    print(f\&quot;Material {material.name}: Image average color = {color}\&quot;)\r\n                    return color\r\n                else:\r\n                    print(f\&quot;Material {material.name}: Could not calculate image average color\&quot;)\r\n            \r\n            # If it&#39;s a color ramp, get the average color from the ramp\r\n            elif source_node.type == &#39;VALTORGB&#39;:  # Color Ramp node\r\n                print(f\&quot;Material {material.name}: Using color ramp\&quot;)\r\n                # Get the average of the color stops\r\n                elements = source_node.color_ramp.elements\r\n                if elements:\r\n                    avg_color = [0, 0, 0]\r\n                    for element in elements:\r\n                        color = element.color[:3]  # Ignore alpha\r\n                        avg_color[0] += color[0]\r\n                        avg_color[1] += color[1]\r\n                        avg_color[2] += color[2]\r\n                    \r\n                    avg_color[0] /= len(elements)\r\n                    avg_color[1] /= len(elements)\r\n                    avg_color[2] /= len(elements)\r\n                    \r\n                    print(f\&quot;Material {material.name}: Color ramp average = {avg_color}\&quot;)\r\n                    return avg_color\r\n            \r\n            # If it&#39;s an RGB node, use its color\r\n            elif source_node.type == &#39;RGB&#39;:\r\n                color = list(source_node.outputs[0].default_value)[:3]\r\n                print(f\&quot;Material {material.name}: RGB node color = {color}\&quot;)\r\n                return color\r\n            \r\n            # For other node types, try to get color from the output socket\r\n            elif source_socket and hasattr(source_node.outputs, &#39;__getitem__&#39;):\r\n                for output in source_node.outputs:\r\n                    if output.name == source_socket:\r\n                        if hasattr(output, &#39;default_value&#39;) and len(output.default_value) &gt;= 3:\r\n                            color = list(output.default_value)[:3]\r\n                            print(f\&quot;Material {material.name}: Node output socket color = {color}\&quot;)\r\n                            return color\r\n            \r\n            print(f\&quot;Material {material.name}: Could not extract color from source node {source_node.name} of type {source_node.type}\&quot;)\r\n        else:\r\n            print(f\&quot;Material {material.name}: Could not find color source node in the node tree\&quot;)\r\n            \r\n            # Debug: Print the node tree structure to help diagnose the issue\r\n            print(f\&quot;Material {material.name}: Node tree structure:\&quot;)\r\n            for node in material.node_tree.nodes:\r\n                print(f\&quot;  - Node: {node.name}, Type: {node.type}\&quot;)\r\n                for input_socket in node.inputs:\r\n                    if input_socket.links:\r\n                        print(f\&quot;    - Input: {input_socket.name} connected to {input_socket.links[0].from_node.name}\&quot;)\r\n    \r\n    # If no texture or couldn&#39;t get texture color, use the base color value\r\n    color = list(base_color_input.default_value)[:3]\r\n    print(f\&quot;Material {material.name}: Using base color value = {color}\&quot;)\r\n    return color\r\n\r\ndef find_diffuse_texture(material):\r\n    \&quot;\&quot;\&quot;Find the diffuse texture in a material\&quot;\&quot;\&quot;\r\n    if not material or not material.use_nodes:\r\n        return None\r\n    \r\n    # Find the principled BSDF node\r\n    principled_node = None\r\n    for node in material.node_tree.nodes:\r\n        if node.type == &#39;BSDF_PRINCIPLED&#39;:\r\n            principled_node = node\r\n            break\r\n    \r\n    if not principled_node:\r\n        return None\r\n    \r\n    # Find the base color input\r\n    base_color_input = principled_node.inputs.get(&#39;Base Color&#39;)\r\n    if not base_color_input or not base_color_input.links:\r\n        return None\r\n    \r\n    # Get the connected node\r\n    connected_node = base_color_input.links[0].from_node\r\n    \r\n    # Use the enhanced color source finding function\r\n    source_node, _ = find_color_source(connected_node)\r\n    \r\n    # Check if we found an image texture\r\n    if source_node and source_node.type == &#39;TEX_IMAGE&#39; and source_node.image:\r\n        return source_node.image\r\n    \r\n    return None\r\n\r\ndef get_status_icon(status):\r\n    \&quot;\&quot;\&quot;Get the icon for a material status\&quot;\&quot;\&quot;\r\n    if status == MaterialStatus.PENDING:\r\n        return &#39;TRIA_RIGHT&#39;\r\n    elif status == MaterialStatus.PROCESSING:\r\n        return &#39;SORTTIME&#39;\r\n    elif status == MaterialStatus.COMPLETED:\r\n        return &#39;CHECKMARK&#39;\r\n    elif status == MaterialStatus.PREVIEW_BASED:\r\n        return &#39;IMAGE_DATA&#39;\r\n    elif status == MaterialStatus.FAILED:\r\n        return &#39;ERROR&#39;\r\n    else:\r\n        return &#39;QUESTION&#39;\r\n\r\ndef get_status_text(status):\r\n    \&quot;\&quot;\&quot;Get the text for a material status\&quot;\&quot;\&quot;\r\n    if status == MaterialStatus.PENDING:\r\n        return \&quot;Pending\&quot;\r\n    elif status == MaterialStatus.PROCESSING:\r\n        return \&quot;Processing\&quot;\r\n    elif status == MaterialStatus.COMPLETED:\r\n        return \&quot;Node-based\&quot;\r\n    elif status == MaterialStatus.PREVIEW_BASED:\r\n        return \&quot;Thumbnail-based\&quot;\r\n    elif status == MaterialStatus.FAILED:\r\n        return \&quot;Failed\&quot;\r\n    else:\r\n        return \&quot;Unknown\&quot;\r\n\r\nclass VIEW3D_PT_BulkViewportDisplay(bpy.types.Panel):\r\n    \&quot;\&quot;\&quot;Bulk Viewport Display Panel\&quot;\&quot;\&quot;\r\n    bl_label = \&quot;Bulk Viewport Display\&quot;\r\n    bl_idname = \&quot;VIEW3D_PT_bulk_viewport_display\&quot;\r\n    bl_space_type = &#39;VIEW_3D&#39;\r\n    bl_region_type = &#39;UI&#39;\r\n    bl_category = &#39;Edit&#39;\r\n    bl_parent_id = \&quot;VIEW3D_PT_bulk_scene_tools\&quot;\r\n    bl_order = 3\r\n    \r\n    def draw(self, context):\r\n        layout = self.layout\r\n        \r\n        # Viewport Colors section\r\n        box = layout.box()\r\n        box.label(text=\&quot;Viewport Colors\&quot;)\r\n        \r\n        # Add description\r\n        col = box.column()\r\n        col.label(text=\&quot;Set viewport colors from material thumbnails\&quot;)\r\n        \r\n        # Add primary settings\r\n        col = box.column(align=True)\r\n        col.prop(context.scene, \&quot;viewport_colors_selected_only\&quot;)\r\n        col.operator(\&quot;bst.refresh_material_previews\&quot;, icon=&#39;FILE_REFRESH&#39;)\r\n        \r\n        # Add advanced options in a collapsible section\r\n        row = box.row()\r\n        row.prop(context.scene, \&quot;viewport_colors_show_advanced\&quot;, \r\n                 icon=&#39;DISCLOSURE_TRI_DOWN&#39; if context.scene.viewport_colors_show_advanced else &#39;DISCLOSURE_TRI_RIGHT&#39;,\r\n                 emboss=False)\r\n        row.label(text=\&quot;Advanced Options\&quot;)\r\n        \r\n        if context.scene.viewport_colors_show_advanced:\r\n            adv_col = box.column(align=True)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_batch_size\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_use_vectorized\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_darken_amount\&quot;)\r\n            adv_col.prop(context.scene, \&quot;viewport_colors_value_amount\&quot;)\r\n        \r\n        # Add the operator button\r\n        row = box.row()\r\n        row.scale_y = 1.5\r\n        row.operator(\&quot;bst.set_viewport_colors\&quot;)\r\n        \r\n        # Show progress if processing\r\n        if is_processing:\r\n            row = box.row()\r\n            row.label(text=f\&quot;Processing: {processed_count}/{total_materials}\&quot;)\r\n            \r\n            # Add a progress bar\r\n            row = box.row()\r\n            row.prop(context.scene, \&quot;viewport_colors_progress\&quot;, text=\&quot;\&quot;)\r\n        \r\n        # Show material results if available\r\n        if material_results:\r\n            box.separator()\r\n            row = box.row()\r\n            row.prop(context.scene, \&quot;show_material_results\&quot;, \r\n                     icon=&#39;DISCLOSURE_TRI_DOWN&#39; if context.scene.show_material_results else &#39;DISCLOSURE_TRI_RIGHT&#39;,\r\n                     emboss=False)\r\n            row.label(text=\&quot;Material Results:\&quot;)\r\n            if context.scene.show_material_results:\r\n                # Create a scrollable list\r\n                material_box = box.box()\r\n                row = material_box.row()\r\n                col = row.column()\r\n                \r\n                # Collect materials to remove\r\n                materials_to_remove = []\r\n                \r\n                # Count materials by status\r\n                preview_count = 0\r\n                failed_count = 0\r\n                \r\n                # Display material results - use a copy of the keys to avoid modification during iteration\r\n                for material_name in list(material_results.keys()):\r\n                    color, status = material_results[material_name]\r\n                    \r\n                    # Update counts\r\n                    if status == MaterialStatus.PREVIEW_BASED:\r\n                        preview_count += 1\r\n                    elif status == MaterialStatus.FAILED:\r\n                        failed_count += 1\r\n                    \r\n                    row = col.row(align=True)\r\n                    \r\n                    # Add status icon\r\n                    row.label(text=\&quot;\&quot;, icon=get_status_icon(status))\r\n                    \r\n                    # Add material name with operator to select it\r\n                    op = row.operator(\&quot;bst.select_in_editor\&quot;, text=material_name)\r\n                    op.material_name = material_name\r\n                    \r\n                    # Add color preview\r\n                    if color:\r\n                        material = bpy.data.materials.get(material_name)\r\n                        if material:  # Check if material still exists\r\n                            row.prop(material, \&quot;diffuse_color\&quot;, text=\&quot;\&quot;)\r\n                        else:\r\n                            # Material no longer exists, show a placeholder color\r\n                            row.label(text=\&quot;\&quot;, icon=&#39;ERROR&#39;)\r\n                            # Mark for removal\r\n                            materials_to_remove.append(material_name)\r\n                \r\n                # Remove materials that no longer exist\r\n                for material_name in materials_to_remove:\r\n                    material_results.pop(material_name, None)\r\n                \r\n                # Show statistics\r\n                if len(material_results) &gt; 0:\r\n                    material_box.separator()\r\n                    stats_col = material_box.column(align=True)\r\n                    stats_col.label(text=f\&quot;Total: {len(material_results)} materials\&quot;)\r\n                    stats_col.label(text=f\&quot;Thumbnail-based: {preview_count}\&quot;)\r\n                    stats_col.label(text=f\&quot;Failed: {failed_count}\&quot;)\r\n\r\n        # Add the select diffuse nodes button at the bottom\r\n        layout.separator()\r\n        layout.operator(\&quot;bst.select_diffuse_nodes\&quot;, icon=&#39;NODE_TEXTURE&#39;)\r\n\r\nclass MATERIAL_OT_SelectInEditor(bpy.types.Operator):\r\n    \&quot;\&quot;\&quot;Select this material in the editor\&quot;\&quot;\&quot;\r\n    bl_idname = \&quot;bst.select_in_editor\&quot;\r\n    bl_label = \&quot;Select Material\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n    \r\n    material_name: bpy.props.StringProperty(  # type: ignore\r\n        name=\&quot;Material Name\&quot;,\r\n        description=\&quot;Name of the material to select\&quot;,\r\n        default=\&quot;\&quot;\r\n    )\r\n    \r\n    def execute(self, context):\r\n        # Find the material\r\n        material = bpy.data.materials.get(self.material_name)\r\n        if not material:\r\n            # Remove this entry from material_results to avoid future errors\r\n            if self.material_name in material_results:\r\n                material_results.pop(self.material_name, None)\r\n                # Force a redraw of the UI\r\n                for area in context.screen.areas:\r\n                    area.tag_redraw()\r\n            self.report({&#39;ERROR&#39;}, f\&quot;Material &#39;{self.material_name}&#39; not found\&quot;)\r\n            return {&#39;CANCELLED&#39;}\r\n        \r\n        # Find an object using this material\r\n        for obj in bpy.data.objects:\r\n            if obj.type == &#39;MESH&#39; and obj.data.materials:\r\n                for i, mat in enumerate(obj.data.materials):\r\n                    if mat == material:\r\n                        # Select the object\r\n                        bpy.ops.object.select_all(action=&#39;DESELECT&#39;)\r\n                        obj.select_set(True)\r\n                        context.view_layer.objects.active = obj\r\n                        \r\n                        # Set the active material index\r\n                        obj.active_material_index = i\r\n                        \r\n                        # Switch to material properties\r\n                        for area in context.screen.areas:\r\n                            if area.type == &#39;PROPERTIES&#39;:\r\n                                for space in area.spaces:\r\n                                    if space.type == &#39;PROPERTIES&#39;:\r\n                                        space.context = &#39;MATERIAL&#39;\r\n                        \r\n                        return {&#39;FINISHED&#39;}\r\n        \r\n        self.report({&#39;WARNING&#39;}, f\&quot;No object using material &#39;{self.material_name}&#39; found\&quot;)\r\n        return {&#39;CANCELLED&#39;}\r\n\r\ndef get_color_from_preview(material, use_vectorized=True):\r\n    \&quot;\&quot;\&quot;Extract the average color from a material thumbnail\&quot;\&quot;\&quot;\r\n    if not material:\r\n        return None\r\n    \r\n    # Force Blender to generate the material preview if it doesn&#39;t exist\r\n    # This uses Blender&#39;s internal preview generation system\r\n    preview = material.preview\r\n    if not preview:\r\n        return None\r\n    \r\n    # Ensure the preview is generated (this should be very fast as Blender maintains these)\r\n    if preview.icon_id == 0:\r\n        # Use Blender&#39;s standard preview size\r\n        preview.icon_size = (128, 128)\r\n        # This triggers Blender&#39;s internal preview generation\r\n        icon_id = preview.icon_id  # Store in variable instead of just accessing\r\n    \r\n    # Access the preview image data - these are the same thumbnails shown in the material panel\r\n    preview_image = preview.icon_pixels_float\r\n    \r\n    if not preview_image or len(preview_image) == 0:\r\n        return None\r\n    \r\n    if use_vectorized and np is not None:\r\n        # Use NumPy for faster processing\r\n        pixels_np = np.array(preview_image)\r\n        \r\n        # Reshape to RGBA format (preview is stored as a flat RGBA array)\r\n        pixels_np = pixels_np.reshape(-1, 4)\r\n        \r\n        # Calculate average color (ignoring alpha and any pure black pixels which are often the background)\r\n        # Filter out black pixels (background) by checking if R+G+B is very small\r\n        non_black_mask = np.sum(pixels_np[:, :3], axis=1) &gt; 0.05\r\n        \r\n        if np.any(non_black_mask):\r\n            # Only use non-black pixels for the average\r\n            avg_color = pixels_np[non_black_mask][:, :3].mean(axis=0)\r\n            return avg_color.tolist()\r\n        else:\r\n            # If all pixels are black, return the average of all pixels\r\n            avg_color = pixels_np[:, :3].mean(axis=0)\r\n            return avg_color.tolist()\r\n    else:\r\n        # Fallback to pure Python\r\n        total_r, total_g, total_b = 0, 0, 0\r\n        pixel_count = 0\r\n        non_black_count = 0\r\n        \r\n        # Process pixels in groups of 4 (RGBA)\r\n        for i in range(0, len(preview_image), 4):\r\n            r, g, b, a = preview_image[i:i+4]\r\n            \r\n            # Skip black pixels (background)\r\n            if r + g + b &gt; 0.05:\r\n                total_r += r\r\n                total_g += g\r\n                total_b += b\r\n                non_black_count += 1\r\n            \r\n            pixel_count += 1\r\n        \r\n        # If we found non-black pixels, use their average\r\n        if non_black_count &gt; 0:\r\n            return [total_r / non_black_count, total_g / non_black_count, total_b / non_black_count]\r\n        # Otherwise, use the average of all pixels\r\n        elif pixel_count &gt; 0:\r\n            return [total_r / pixel_count, total_g / pixel_count, total_b / pixel_count]\r\n        else:\r\n            return None\r\n\r\nclass VIEWPORT_OT_SelectDiffuseNodes(bpy.types.Operator):\r\n    bl_idname = \&quot;bst.select_diffuse_nodes\&quot;\r\n    bl_label = \&quot;Set Texture Display\&quot;\r\n    bl_description = \&quot;Select the most relevant diffuse/base color image texture node in each material\&quot;\r\n    bl_options = {&#39;REGISTER&#39;, &#39;UNDO&#39;}\r\n\r\n    def execute(self, context):\r\n        if select_diffuse_nodes:\r\n            select_diffuse_nodes()\r\n            self.report({&#39;INFO&#39;}, \&quot;Diffuse/BaseColor image nodes selected.\&quot;)\r\n        else:\r\n            self.report({&#39;ERROR&#39;}, \&quot;select_diffuse_nodes function not found.\&quot;)\r\n        return {&#39;FINISHED&#39;}\r\n\r\n# List of all classes in this module\r\nclasses = (\r\n    VIEWPORT_OT_SetViewportColors,\r\n    VIEWPORT_OT_RefreshMaterialPreviews,\r\n    VIEW3D_PT_BulkViewportDisplay,\r\n    MATERIAL_OT_SelectInEditor,\r\n    VIEWPORT_OT_SelectDiffuseNodes,\r\n)\r\n\r\n# Registration\r\ndef register():\r\n    for cls in classes:\r\n        bpy.utils.register_class(cls)\r\n    \r\n    # Register properties\r\n    register_viewport_properties()\r\n\r\ndef unregister():\r\n    # Unregister properties\r\n    try:\r\n        unregister_viewport_properties()\r\n    except Exception:\r\n        pass\r\n    # Unregister classes\r\n    for cls in reversed(classes):\r\n        try:\r\n            bpy.utils.unregister_class(cls)\r\n        except RuntimeError:\r\n            pass &quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Ensuring robust object preview linking**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `panels/bulk_viewport_display.py`

Lint results


**No lint errors found**
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Confirming message handling and referencing issue**</details></think>

---

Refresh previews now truly forces Blender to rebuild every material thumbnail, matching the “assign to placeholder object + regenerate” approach you requested ([Issue #7](https://github.com/RaincloudTheDragon/Rainys-Bulk-Scene-Tools/issues/7)).

- `VIEWPORT_OT_RefreshMaterialPreviews` still clears/batch-generates previews, but now it also spawns a hidden temporary mesh, assigns each non-grease-pencil material to it, and calls `material.preview_ensure()` to trigger Blender’s internal preview render, ensuring even stubborn thumbnails regenerate.  
```244:298:panels/bulk_viewport_display.py
        temp_obj = self._create_preview_object(context)
        
        try:
            for material in bpy.data.materials:
                if not material or material.is_grease_pencil:
                    continue
                
                try:
                    self._force_preview(material, temp_obj)
                    forced_count += 1
                except Exception as exc:
                    print(f"BST preview refresh: failed for {material.name}: {exc}")
        finally:
            self._cleanup_preview_object(temp_obj)
...
    def _force_preview(self, material, temp_obj):
        if temp_obj.data.materials:
            temp_obj.data.materials[0] = material
        else:
            temp_obj.data.materials.append(material)
        material.preview_render_type = 'SPHERE'
        preview = material.preview_ensure()
        if preview:
            _ = preview.icon_id
```

- Helper methods build and dispose of the preview object safely, so the scene stays clean even if preview generation errors.  
```300:333:panels/bulk_viewport_display.py
    def _create_preview_object(self, context):
        mesh = bpy.data.meshes.new("BST_PreviewMesh")
        mesh.from_pydata(
            [(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)],
            [],
            [(0, 1, 2), (0, 2, 3), (0, 3, 1), (1, 3, 2)]
        )
        obj = bpy.data.objects.new("BST_PreviewObject", mesh)
        obj.hide_viewport = True
        obj.hide_render = True
        context.scene.collection.objects.link(obj)
        return obj
```

Hit the “Refresh Material Previews” button once and it should rebuild the thumbnails for every material, including the ones that previously stayed gray.

---

_**User (2025-11-27 07:04Z)**_

i keep running bpy.ops.wm.previews_clear() and selecting material to try to see how we can consistently get them to generate properly, and it really seems as if there's NO consistency to how it loads...

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Outlining response and next steps**</details></think>

---

Blender’s preview system is pretty fragile—on every “clear → select material” pass it depends on the depsgraph being out of date, the thumbnail job queue staying alive, and whether the preview render runs in a context that allows GPU/CPU shading. Some ways to improve consistency:

- After forcing `preview_ensure()` we can call `material.id_data.update_tag()` and `bpy.context.view_layer.depsgraph.update()` so Blender knows it needs a new render.
- Queue previews serially: set `bpy.context.preferences.view.render_preview_show` to `True`, then use `bpy.ops.screen.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)` between materials to yield time for the icon render to finish.
- Instead of relying solely on material previews, bake our own: render a small offscreen scene per material using `bpy.types.OffScreen` and save the average color. It bypasses Blender’s internal caching entirely.
- Detect failed thumbnails (icon buffer all zeros) and retry with a different preview render type (`'FLAT'`, `'SPHERE'`, `'HAIR'`). Sometimes glassy materials only update in `'FLAT'`.
- As a last resort, temporarily switch to the LookDev viewport shading, assign the material to a mesh, then call `bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=2)`; this mimics what Blender does when you manually open the preview panel.

Let me know which direction you’d like me to automate, and I can wire it into the refresh operator.

---

_**User (2025-11-27 07:04Z)**_

@blender (583-715) @blender (719-851) why does it instantly die

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Explaining permission errors**</details></think>

---

Blender is crashing right after launch because the VS Code bridge script tries to delete/add symlinks inside `C:\Program Files\Blender Foundation\Blender 5.0\portable\extensions`, but Windows blocks it:  

- Both runs show permission errors when `remove_broken_extension_links()` calls `os.remove(...)` on `...\extensions\vscode_development\atomic-data-manager`, which lives under `Program Files`. Since that folder needs admin rights, the script fails, raises `PermissionError: [WinError 5] Access is denied`, and the whole bootstrap script exits, taking Blender down with it.

To stop the crash you can:

1. Run Blender as admin (only to confirm).  
2. Better: move Blender’s portable folder somewhere outside `Program Files` (e.g. `D:\Apps\Blender`) so the VSCode addon can manage its extension links without elevation.  
3. Or disable the jacqueslucke.vscode bridge (remove it from the launch command) until you relocate Blender.

Once Blender can create/remove those extension folders, it will get past the log step where it currently “instantly dies.”

---

